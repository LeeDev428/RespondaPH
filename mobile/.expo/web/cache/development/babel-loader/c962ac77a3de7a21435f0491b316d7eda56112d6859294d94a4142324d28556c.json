{"ast":null,"code":"var $3XJlT$react = require(\"react\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"useTypeSelect\", function () {\n  return $a1189052f36475e8$export$e32c88dfddc6e1d8;\n});\nvar $a1189052f36475e8$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000;\nfunction $a1189052f36475e8$export$e32c88dfddc6e1d8(options) {\n  var keyboardDelegate = options.keyboardDelegate,\n    selectionManager = options.selectionManager,\n    onTypeSelect = options.onTypeSelect;\n  var state = (0, $3XJlT$react.useRef)({\n    search: '',\n    timeout: undefined\n  }).current;\n  var onKeyDown = function onKeyDown(e) {\n    var character = $a1189052f36475e8$var$getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target) || state.search.length === 0 && character === ' ') return;\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) e.stopPropagation();\n    }\n    state.search += character;\n    if (keyboardDelegate.getKeyForSearch != null) {\n      var key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n      if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);\n      if (key != null) {\n        selectionManager.setFocusedKey(key);\n        if (onTypeSelect) onTypeSelect(key);\n      }\n    }\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function () {\n      state.search = '';\n    }, $a1189052f36475e8$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n  return {\n    typeSelectProps: {\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : undefined\n    }\n  };\n}\nfunction $a1189052f36475e8$var$getStringForKey(key) {\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;\n  return '';\n}","map":{"version":3,"names":["$a1189052f36475e8$var$TYPEAHEAD_DEBOUNCE_WAIT_MS","$a1189052f36475e8$export$e32c88dfddc6e1d8","options","keyboardDelegate","selectionManager","onTypeSelect","state","$3XJlT$react","useRef","search","timeout","undefined","current","onKeyDown","e","character","$a1189052f36475e8$var$getStringForKey","key","ctrlKey","metaKey","currentTarget","contains","target","length","trim","preventDefault","stopPropagation","getKeyForSearch","focusedKey","setFocusedKey","clearTimeout","setTimeout","typeSelectProps","onKeyDownCapture","test"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useTypeSelect.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, Key, KeyboardDelegate} from '@react-types/shared';\nimport {KeyboardEvent, useRef} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\n/**\n * Controls how long to wait before clearing the typeahead buffer.\n */\nconst TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\n\nexport interface AriaTypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\nexport interface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: DOMAttributes\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: AriaTypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef<{search: string, timeout: ReturnType<typeof setTimeout> | undefined}>({\n    search: '',\n    timeout: undefined\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target as HTMLElement) || (state.search.length === 0 && character === ' ')) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    if (keyboardDelegate.getKeyForSearch != null) {\n      // Use the delegate to find a key to focus.\n      // Prioritize items after the currently focused item, falling back to searching the whole list.\n      let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n      // If no key found, search from the top.\n      if (key == null) {\n        key = keyboardDelegate.getKeyForSearch(state.search);\n      }\n\n      if (key != null) {\n        selectionManager.setFocusedKey(key);\n        if (onTypeSelect) {\n          onTypeSelect(key);\n        }\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : undefined\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n"],"mappings":";;;;;;;;;;;;AAmBA,IAAMA,gDAAA,GAA6B;AA2B5B,SAASC,0CAAcC,OAA8B;EAC1D,IAAKC,gBAAgB,GAAoCD,OAAA,CAArDC,gBAAA;IAAmBC,gBAAgB,GAAkBF,OAAA,CAApCE,gBAAA;IAAoBC,YAAY,GAAIH,OAAA,CAAlBG,YAAA;EACvC,IAAIC,KAAA,GAAQ,IAAAC,YAAA,CAAAC,MAAK,EAAwE;IACvFC,MAAA,EAAQ;IACRC,OAAA,EAASC;EACX,GAAGC,OAAO;EAEV,IAAIC,SAAA,GAAY,SAAZA,UAAaC,CAAA;IACf,IAAIC,SAAA,GAAYC,qCAAA,CAAgBF,CAAA,CAAEG,GAAG;IACrC,IAAI,CAACF,SAAA,IAAaD,CAAA,CAAEI,OAAO,IAAIJ,CAAA,CAAEK,OAAO,IAAI,CAACL,CAAA,CAAEM,aAAa,CAACC,QAAQ,CAACP,CAAA,CAAEQ,MAAM,KAAqBhB,KAAA,CAAMG,MAAM,CAACc,MAAM,KAAK,KAAKR,SAAA,KAAc,KAC5I;IAOF,IAAIA,SAAA,KAAc,OAAOT,KAAA,CAAMG,MAAM,CAACe,IAAI,GAAGD,MAAM,GAAG,GAAG;MACvDT,CAAA,CAAEW,cAAc;MAChB,IAAI,EAAE,yBAAyBX,CAAA,GAC7BA,CAAA,CAAEY,eAAe;IAErB;IAEApB,KAAA,CAAMG,MAAM,IAAIM,SAAA;IAEhB,IAAIZ,gBAAA,CAAiBwB,eAAe,IAAI,MAAM;MAG5C,IAAIV,GAAA,GAAMd,gBAAA,CAAiBwB,eAAe,CAACrB,KAAA,CAAMG,MAAM,EAAEL,gBAAA,CAAiBwB,UAAU;MAGpF,IAAIX,GAAA,IAAO,MACTA,GAAA,GAAMd,gBAAA,CAAiBwB,eAAe,CAACrB,KAAA,CAAMG,MAAM;MAGrD,IAAIQ,GAAA,IAAO,MAAM;QACfb,gBAAA,CAAiByB,aAAa,CAACZ,GAAA;QAC/B,IAAIZ,YAAA,EACFA,YAAA,CAAaY,GAAA;MAEjB;IACF;IAEAa,YAAA,CAAaxB,KAAA,CAAMI,OAAO;IAC1BJ,KAAA,CAAMI,OAAO,GAAGqB,UAAA,CAAW;MACzBzB,KAAA,CAAMG,MAAM,GAAG;IACjB,GAAGT,gDAAA;EACL;EAEA,OAAO;IACLgC,eAAA,EAAiB;MAGfC,gBAAA,EAAkB9B,gBAAA,CAAiBwB,eAAe,GAAGd,SAAA,GAAYF;IACnE;EACF;AACF;AAEA,SAASK,sCAAgBC,GAAW;EAKlC,IAAIA,GAAA,CAAIM,MAAM,KAAK,KAAK,CAAC,UAAUW,IAAI,CAACjB,GAAA,GACtC,OAAOA,GAAA;EAGT,OAAO;AACT","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}