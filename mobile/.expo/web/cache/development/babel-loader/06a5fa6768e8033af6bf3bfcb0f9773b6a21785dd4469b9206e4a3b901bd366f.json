{"ast":null,"code":"var _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar $1254e5bb94ac8761$exports = require(\"./useEffectEvent.main.js\");\nvar $78605a5d7424e31b$exports = require(\"./useLayoutEffect.main.js\");\nvar $fymK9$react = require(\"react\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"useValueEffect\", function () {\n  return $19a2307bfabafaf1$export$14d238f342723f25;\n});\nfunction $19a2307bfabafaf1$export$14d238f342723f25(defaultValue) {\n  var _ref = (0, $fymK9$react.useState)(defaultValue),\n    _ref2 = _slicedToArray(_ref, 2),\n    value = _ref2[0],\n    setValue = _ref2[1];\n  var effect = (0, $fymK9$react.useRef)(null);\n  var nextRef = (0, $1254e5bb94ac8761$exports.useEffectEvent)(function () {\n    if (!effect.current) return;\n    var newValue = effect.current.next();\n    if (newValue.done) {\n      effect.current = null;\n      return;\n    }\n    if (value === newValue.value) nextRef();else setValue(newValue.value);\n  });\n  (0, $78605a5d7424e31b$exports.useLayoutEffect)(function () {\n    if (effect.current) nextRef();\n  });\n  var queue = (0, $1254e5bb94ac8761$exports.useEffectEvent)(function (fn) {\n    effect.current = fn(value);\n    nextRef();\n  });\n  return [value, queue];\n}","map":{"version":3,"names":["$19a2307bfabafaf1$export$14d238f342723f25","defaultValue","_ref","$fymK9$react","useState","_ref2","_slicedToArray","value","setValue","effect","useRef","nextRef","$1254e5bb94ac8761$exports","useEffectEvent","current","newValue","next","done","$78605a5d7424e31b$exports","useLayoutEffect","queue","fn"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\utils\\dist\\packages\\@react-aria\\utils\\src\\useValueEffect.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Dispatch, MutableRefObject, useRef, useState} from 'react';\nimport {useEffectEvent, useLayoutEffect} from './';\n\ntype SetValueAction<S> = (prev: S) => Generator<any, void, unknown>;\n\n// This hook works like `useState`, but when setting the value, you pass a generator function\n// that can yield multiple values. Each yielded value updates the state and waits for the next\n// layout effect, then continues the generator. This allows sequential updates to state to be\n// written linearly.\nexport function useValueEffect<S>(defaultValue: S | (() => S)): [S, Dispatch<SetValueAction<S>>] {\n  let [value, setValue] = useState(defaultValue);\n  let effect: MutableRefObject<Generator<S> | null> = useRef<Generator<S> | null>(null);\n\n  // Store the function in a ref so we can always access the current version\n  // which has the proper `value` in scope.\n  let nextRef = useEffectEvent(() => {\n    if (!effect.current) {\n      return;\n    }\n    // Run the generator to the next yield.\n    let newValue = effect.current.next();\n\n    // If the generator is done, reset the effect.\n    if (newValue.done) {\n      effect.current = null;\n      return;\n    }\n\n    // If the value is the same as the current value,\n    // then continue to the next yield. Otherwise,\n    // set the value in state and wait for the next layout effect.\n    if (value === newValue.value) {\n      nextRef();\n    } else {\n      setValue(newValue.value);\n    }\n  });\n\n  useLayoutEffect(() => {\n    // If there is an effect currently running, continue to the next yield.\n    if (effect.current) {\n      nextRef();\n    }\n  });\n\n  let queue = useEffectEvent(fn => {\n    effect.current = fn(value);\n    nextRef();\n  });\n\n  return [value, queue];\n}\n"],"mappings":";;;;;;;;;;;;;;;AAqBO,SAASA,0CAAkBC,YAA2B;EAC3D,IAAAC,IAAA,GAAwB,IAAAC,YAAA,CAAAC,QAAO,EAAEH,YAAA;IAAAI,KAAA,GAAAC,cAAA,CAAAJ,IAAA;IAA5BK,KAAA,GAAAF,KAAA;IAAOG,QAAA,GAAAH,KAAA;EACZ,IAAII,MAAA,GAAgD,IAAAN,YAAA,CAAAO,MAAK,EAAuB;EAIhF,IAAIC,OAAA,GAAU,IAAAC,yBAAA,CAAAC,cAAa,EAAE;IAC3B,IAAI,CAACJ,MAAA,CAAOK,OAAO,EACjB;IAGF,IAAIC,QAAA,GAAWN,MAAA,CAAOK,OAAO,CAACE,IAAI;IAGlC,IAAID,QAAA,CAASE,IAAI,EAAE;MACjBR,MAAA,CAAOK,OAAO,GAAG;MACjB;IACF;IAKA,IAAIP,KAAA,KAAUQ,QAAA,CAASR,KAAK,EAC1BI,OAAA,QAEAH,QAAA,CAASO,QAAA,CAASR,KAAK;EAE3B;EAEA,IAAAW,yBAAA,CAAAC,eAAc,EAAE;IAEd,IAAIV,MAAA,CAAOK,OAAO,EAChBH,OAAA;EAEJ;EAEA,IAAIS,KAAA,GAAQ,IAAAR,yBAAA,CAAAC,cAAa,EAAE,UAAAQ,EAAA;IACzBZ,MAAA,CAAOK,OAAO,GAAGO,EAAA,CAAGd,KAAA;IACpBI,OAAA;EACF;EAEA,OAAO,CAACJ,KAAA,EAAOa,KAAA,CAAM;AACvB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}