{"ast":null,"code":"var _readOnlyError = require(\"@babel/runtime/helpers/readOnlyError\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar $d723bea02f3e2567$exports = require(\"./DOMFunctions.main.js\");\nvar $hdE3O$reactstatelyflags = require(\"@react-stately/flags\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"ShadowTreeWalker\", function () {\n  return $8e13b2545651735a$export$63eb3ababa9c55c4;\n});\n$parcel$export(module.exports, \"createShadowTreeWalker\", function () {\n  return $8e13b2545651735a$export$4d0f8be8b12a7ef6;\n});\nvar $8e13b2545651735a$export$63eb3ababa9c55c4 = function () {\n  \"use strict\";\n\n  function $8e13b2545651735a$export$63eb3ababa9c55c4(doc, root, whatToShow, filter) {\n    var _this = this;\n    _classCallCheck(this, $8e13b2545651735a$export$63eb3ababa9c55c4);\n    this._walkerStack = [];\n    this._currentSetFor = new Set();\n    this._acceptNode = function (node) {\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        var _shadowRoot = node.shadowRoot;\n        if (_shadowRoot) {\n          var walker = _this._doc.createTreeWalker(_shadowRoot, _this.whatToShow, {\n            acceptNode: _this._acceptNode\n          });\n          _this._walkerStack.unshift(walker);\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          var _this_filter;\n          if (typeof _this.filter === 'function') return _this.filter(node);else if ((_this_filter = _this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) return _this.filter.acceptNode(node);else if (_this.filter === null) return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n      return NodeFilter.FILTER_SKIP;\n    };\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter !== null && filter !== void 0 ? filter : null;\n    this.whatToShow = whatToShow !== null && whatToShow !== void 0 ? whatToShow : NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n    this._walkerStack.unshift(doc.createTreeWalker(root, whatToShow, this._acceptNode));\n    var shadowRoot = root.shadowRoot;\n    if (shadowRoot) {\n      var walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n      this._walkerStack.unshift(walker);\n    }\n  }\n  return _createClass($8e13b2545651735a$export$63eb3ababa9c55c4, [{\n    key: \"currentNode\",\n    get: function get() {\n      return this._currentNode;\n    },\n    set: function set(node) {\n      if (!(0, $d723bea02f3e2567$exports.nodeContains)(this.root, node)) throw new Error('Cannot set currentNode to a node that is not contained by the root node.');\n      var walkers = [];\n      var curNode = node;\n      var currentWalkerCurrentNode = node;\n      this._currentNode = node;\n      while (curNode && curNode !== this.root) if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        var shadowRoot = curNode;\n        var _walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n          acceptNode: this._acceptNode\n        });\n        walkers.push(_walker);\n        _walker.currentNode = currentWalkerCurrentNode;\n        this._currentSetFor.add(_walker);\n        curNode = currentWalkerCurrentNode = shadowRoot.host;\n      } else curNode = curNode.parentNode;\n      var walker = this._doc.createTreeWalker(this.root, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n      walkers.push(walker);\n      walker.currentNode = currentWalkerCurrentNode;\n      this._currentSetFor.add(walker);\n      this._walkerStack = walkers;\n    }\n  }, {\n    key: \"doc\",\n    get: function get() {\n      return this._doc;\n    }\n  }, {\n    key: \"firstChild\",\n    value: function firstChild() {\n      var currentNode = this.currentNode;\n      var newNode = this.nextNode();\n      if (!(0, $d723bea02f3e2567$exports.nodeContains)(currentNode, newNode)) {\n        this.currentNode = currentNode;\n        return null;\n      }\n      if (newNode) this.currentNode = newNode;\n      return newNode;\n    }\n  }, {\n    key: \"lastChild\",\n    value: function lastChild() {\n      var walker = this._walkerStack[0];\n      var newNode = walker.lastChild();\n      if (newNode) this.currentNode = newNode;\n      return newNode;\n    }\n  }, {\n    key: \"nextNode\",\n    value: function nextNode() {\n      var nextNode = this._walkerStack[0].nextNode();\n      if (nextNode) {\n        var shadowRoot = nextNode.shadowRoot;\n        if (shadowRoot) {\n          var _this_filter;\n          var nodeResult;\n          if (typeof this.filter === 'function') nodeResult = this.filter(nextNode);else if ((_this_filter = this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) nodeResult = this.filter.acceptNode(nextNode);\n          if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n            this.currentNode = nextNode;\n            return nextNode;\n          }\n          var newNode = this.nextNode();\n          if (newNode) this.currentNode = newNode;\n          return newNode;\n        }\n        if (nextNode) this.currentNode = nextNode;\n        return nextNode;\n      } else {\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n          var _newNode = this.nextNode();\n          if (_newNode) this.currentNode = _newNode;\n          return _newNode;\n        } else return null;\n      }\n    }\n  }, {\n    key: \"previousNode\",\n    value: function previousNode() {\n      var currentWalker = this._walkerStack[0];\n      if (currentWalker.currentNode === currentWalker.root) {\n        if (this._currentSetFor.has(currentWalker)) {\n          this._currentSetFor.delete(currentWalker);\n          if (this._walkerStack.length > 1) {\n            this._walkerStack.shift();\n            var newNode = this.previousNode();\n            if (newNode) this.currentNode = newNode;\n            return newNode;\n          } else return null;\n        }\n        return null;\n      }\n      var previousNode = currentWalker.previousNode();\n      if (previousNode) {\n        var shadowRoot = previousNode.shadowRoot;\n        if (shadowRoot) {\n          var _this_filter;\n          var nodeResult;\n          if (typeof this.filter === 'function') nodeResult = this.filter(previousNode);else if ((_this_filter = this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) nodeResult = this.filter.acceptNode(previousNode);\n          if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n            if (previousNode) this.currentNode = previousNode;\n            return previousNode;\n          }\n          var _newNode2 = this.lastChild();\n          if (_newNode2) this.currentNode = _newNode2;\n          return _newNode2;\n        }\n        if (previousNode) this.currentNode = previousNode;\n        return previousNode;\n      } else {\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n          var _newNode3 = this.previousNode();\n          if (_newNode3) this.currentNode = _newNode3;\n          return _newNode3;\n        } else return null;\n      }\n    }\n  }, {\n    key: \"nextSibling\",\n    value: function nextSibling() {\n      return null;\n    }\n  }, {\n    key: \"previousSibling\",\n    value: function previousSibling() {\n      return null;\n    }\n  }, {\n    key: \"parentNode\",\n    value: function parentNode() {\n      return null;\n    }\n  }]);\n}();\nfunction $8e13b2545651735a$export$4d0f8be8b12a7ef6(doc, root, whatToShow, filter) {\n  if ((0, $hdE3O$reactstatelyflags.shadowDOM)()) return new $8e13b2545651735a$export$63eb3ababa9c55c4(doc, root, whatToShow, filter);\n  return doc.createTreeWalker(root, whatToShow, filter);\n}","map":{"version":3,"names":["$8e13b2545651735a$export$63eb3ababa9c55c4","doc","root","whatToShow","filter","_this","_classCallCheck","_walkerStack","_currentSetFor","Set","_acceptNode","node","nodeType","Node","ELEMENT_NODE","shadowRoot","walker","_doc","createTreeWalker","acceptNode","unshift","NodeFilter","FILTER_ACCEPT","_this_filter","FILTER_SKIP","SHOW_ALL","_currentNode","_createClass","key","get","set","$d723bea02f3e2567$exports","nodeContains","Error","walkers","curNode","currentWalkerCurrentNode","DOCUMENT_FRAGMENT_NODE","push","currentNode","add","host","parentNode","value","firstChild","newNode","nextNode","lastChild","nodeResult","length","shift","previousNode","currentWalker","has","delete","nextSibling","previousSibling","$8e13b2545651735a$export$4d0f8be8b12a7ef6","$hdE3O$reactstatelyflags","shadowDOM"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\utils\\dist\\packages\\@react-aria\\utils\\src\\shadowdom\\ShadowTreeWalker.ts"],"sourcesContent":["// https://github.com/microsoft/tabster/blob/a89fc5d7e332d48f68d03b1ca6e344489d1c3898/src/Shadowdomize/ShadowTreeWalker.ts\n\nimport {nodeContains} from './DOMFunctions';\nimport {shadowDOM} from '@react-stately/flags';\n\nexport class ShadowTreeWalker implements TreeWalker {\n  public readonly filter: NodeFilter | null;\n  public readonly root: Node;\n  public readonly whatToShow: number;\n\n  private _doc: Document;\n  private _walkerStack: Array<TreeWalker> = [];\n  private _currentNode: Node;\n  private _currentSetFor: Set<TreeWalker> = new Set();\n\n  constructor(\n      doc: Document,\n      root: Node,\n      whatToShow?: number,\n      filter?: NodeFilter | null\n    ) {\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter ?? null;\n    this.whatToShow = whatToShow ?? NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n\n    this._walkerStack.unshift(\n      doc.createTreeWalker(root, whatToShow, this._acceptNode)\n    );\n\n    const shadowRoot = (root as Element).shadowRoot;\n\n    if (shadowRoot) {\n      const walker = this._doc.createTreeWalker(\n        shadowRoot,\n        this.whatToShow,\n        {acceptNode: this._acceptNode}\n      );\n\n      this._walkerStack.unshift(walker);\n    }\n  }\n\n  private _acceptNode = (node: Node): number => {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const shadowRoot = (node as Element).shadowRoot;\n\n      if (shadowRoot) {\n        const walker = this._doc.createTreeWalker(\n          shadowRoot,\n          this.whatToShow,\n          {acceptNode: this._acceptNode}\n        );\n\n        this._walkerStack.unshift(walker);\n\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        if (typeof this.filter === 'function') {\n          return this.filter(node);\n        } else if (this.filter?.acceptNode) {\n          return this.filter.acceptNode(node);\n        } else if (this.filter === null) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n    }\n\n    return NodeFilter.FILTER_SKIP;\n  };\n\n  public get currentNode(): Node {\n    return this._currentNode;\n  }\n\n  public set currentNode(node: Node) {\n    if (!nodeContains(this.root, node)) {\n      throw new Error(\n        'Cannot set currentNode to a node that is not contained by the root node.'\n      );\n    }\n\n    const walkers: TreeWalker[] = [];\n    let curNode: Node | null | undefined = node;\n    let currentWalkerCurrentNode = node;\n\n    this._currentNode = node;\n\n    while (curNode && curNode !== this.root) {\n      if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        const shadowRoot = curNode as ShadowRoot;\n\n        const walker = this._doc.createTreeWalker(\n          shadowRoot,\n          this.whatToShow,\n          {acceptNode: this._acceptNode}\n        );\n\n        walkers.push(walker);\n\n        walker.currentNode = currentWalkerCurrentNode;\n\n        this._currentSetFor.add(walker);\n\n        curNode = currentWalkerCurrentNode = shadowRoot.host;\n      } else {\n        curNode = curNode.parentNode;\n      }\n    }\n\n    const walker = this._doc.createTreeWalker(\n      this.root,\n      this.whatToShow,\n      {acceptNode: this._acceptNode}\n    );\n\n    walkers.push(walker);\n\n    walker.currentNode = currentWalkerCurrentNode;\n\n    this._currentSetFor.add(walker);\n\n    this._walkerStack = walkers;\n  }\n\n  public get doc(): Document {\n    return this._doc;\n  }\n\n  public firstChild(): Node | null {\n    let currentNode = this.currentNode;\n    let newNode = this.nextNode();\n    if (!nodeContains(currentNode, newNode)) {\n      this.currentNode = currentNode;\n      return null;\n    }\n    if (newNode) {\n      this.currentNode = newNode;\n    }\n    return newNode;\n  }\n\n  public lastChild(): Node | null {\n    let walker = this._walkerStack[0];\n    let newNode = walker.lastChild();\n    if (newNode) {\n      this.currentNode = newNode;\n    }\n    return newNode;\n  }\n\n  public nextNode(): Node | null {\n    const nextNode = this._walkerStack[0].nextNode();\n\n    if (nextNode) {\n      const shadowRoot = (nextNode as Element).shadowRoot;\n\n      if (shadowRoot) {\n        let nodeResult: number | undefined;\n\n        if (typeof this.filter === 'function') {\n          nodeResult = this.filter(nextNode);\n        } else if (this.filter?.acceptNode) {\n          nodeResult = this.filter.acceptNode(nextNode);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          this.currentNode = nextNode;\n          return nextNode;\n        }\n\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        let newNode = this.nextNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      }\n\n      if (nextNode) {\n        this.currentNode = nextNode;\n      }\n      return nextNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        let newNode = this.nextNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  public previousNode(): Node | null {\n    const currentWalker = this._walkerStack[0];\n\n    if (currentWalker.currentNode === currentWalker.root) {\n      if (this._currentSetFor.has(currentWalker)) {\n        this._currentSetFor.delete(currentWalker);\n\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n          let newNode = this.previousNode();\n          if (newNode) {\n            this.currentNode = newNode;\n          }\n          return newNode;\n        } else {\n          return null;\n        }\n      }\n\n      return null;\n    }\n\n    const previousNode = currentWalker.previousNode();\n\n    if (previousNode) {\n      const shadowRoot = (previousNode as Element).shadowRoot;\n\n      if (shadowRoot) {\n        let nodeResult: number | undefined;\n\n        if (typeof this.filter === 'function') {\n          nodeResult = this.filter(previousNode);\n        } else if (this.filter?.acceptNode) {\n          nodeResult = this.filter.acceptNode(previousNode);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          if (previousNode) {\n            this.currentNode = previousNode;\n          }\n          return previousNode;\n        }\n\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        let newNode = this.lastChild();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      }\n\n      if (previousNode) {\n        this.currentNode = previousNode;\n      }\n      return previousNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        let newNode = this.previousNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      } else {\n        return null;\n      }\n    }\n  }\n\n    /**\n     * @deprecated\n     */\n  public nextSibling(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n\n    /**\n     * @deprecated\n     */\n  public previousSibling(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n\n    /**\n     * @deprecated\n     */\n  public parentNode(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n}\n\n/**\n * ShadowDOM safe version of document.createTreeWalker.\n */\nexport function createShadowTreeWalker(\n    doc: Document,\n    root: Node,\n    whatToShow?: number,\n    filter?: NodeFilter | null\n): TreeWalker {\n  if (shadowDOM()) {\n    return new ShadowTreeWalker(doc, root, whatToShow, filter);\n  }\n  return doc.createTreeWalker(root, whatToShow, filter);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}