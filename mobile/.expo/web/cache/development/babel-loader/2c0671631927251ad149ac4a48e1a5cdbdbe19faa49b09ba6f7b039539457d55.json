{"ast":null,"code":"var _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"ListCollection\", function () {\n  return $c9aa5a224613c979$export$d085fb9e920b5ca7;\n});\nvar $c9aa5a224613c979$export$d085fb9e920b5ca7 = function () {\n  \"use strict\";\n\n  function $c9aa5a224613c979$export$d085fb9e920b5ca7(nodes) {\n    var _this = this;\n    _classCallCheck(this, $c9aa5a224613c979$export$d085fb9e920b5ca7);\n    this.keyMap = new Map();\n    this.firstKey = null;\n    this.lastKey = null;\n    this.iterable = nodes;\n    var _visit = function visit(node) {\n      _this.keyMap.set(node.key, node);\n      if (node.childNodes && node.type === 'section') for (var child of node.childNodes) _visit(child);\n    };\n    for (var node of nodes) _visit(node);\n    var last = null;\n    var index = 0;\n    var size = 0;\n    for (var _ref of this.keyMap) {\n      var _ref2 = _slicedToArray(_ref, 2);\n      var key = _ref2[0];\n      var _node = _ref2[1];\n      if (last) {\n        last.nextKey = key;\n        _node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        _node.prevKey = undefined;\n      }\n      if (_node.type === 'item') _node.index = index++;\n      if (_node.type === 'section' || _node.type === 'item') size++;\n      last = _node;\n      last.nextKey = undefined;\n    }\n    this._size = size;\n    var _last_key;\n    this.lastKey = (_last_key = last === null || last === void 0 ? void 0 : last.key) !== null && _last_key !== void 0 ? _last_key : null;\n  }\n  return _createClass($c9aa5a224613c979$export$d085fb9e920b5ca7, [{\n    key: Symbol.iterator,\n    value: function* value() {\n      yield* this.iterable;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      return this.keyMap.keys();\n    }\n  }, {\n    key: \"getKeyBefore\",\n    value: function getKeyBefore(key) {\n      var node = this.keyMap.get(key);\n      var _node_prevKey;\n      return node ? (_node_prevKey = node.prevKey) !== null && _node_prevKey !== void 0 ? _node_prevKey : null : null;\n    }\n  }, {\n    key: \"getKeyAfter\",\n    value: function getKeyAfter(key) {\n      var node = this.keyMap.get(key);\n      var _node_nextKey;\n      return node ? (_node_nextKey = node.nextKey) !== null && _node_nextKey !== void 0 ? _node_nextKey : null : null;\n    }\n  }, {\n    key: \"getFirstKey\",\n    value: function getFirstKey() {\n      return this.firstKey;\n    }\n  }, {\n    key: \"getLastKey\",\n    value: function getLastKey() {\n      return this.lastKey;\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      var _this_keyMap_get;\n      return (_this_keyMap_get = this.keyMap.get(key)) !== null && _this_keyMap_get !== void 0 ? _this_keyMap_get : null;\n    }\n  }, {\n    key: \"at\",\n    value: function at(idx) {\n      var keys = _toConsumableArray(this.getKeys());\n      return this.getItem(keys[idx]);\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(key) {\n      var node = this.keyMap.get(key);\n      return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n  }]);\n}();","map":{"version":3,"names":["$c9aa5a224613c979$export$d085fb9e920b5ca7","nodes","_this","_classCallCheck","keyMap","Map","firstKey","lastKey","iterable","visit","node","set","key","childNodes","type","child","last","index","size","_ref","_ref2","_slicedToArray","nextKey","prevKey","undefined","_size","_last_key","_createClass","Symbol","iterator","value","get","getKeys","keys","getKeyBefore","_node_prevKey","getKeyAfter","_node_nextKey","getFirstKey","getLastKey","getItem","_this_keyMap_get","at","idx","_toConsumableArray","getChildren"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-stately\\list\\dist\\packages\\@react-stately\\list\\src\\ListCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Key, Node} from '@react-types/shared';\n\nexport class ListCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key | null = null;\n  private lastKey: Key | null = null;\n  private _size: number;\n\n  constructor(nodes: Iterable<Node<T>>) {\n    this.iterable = nodes;\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && node.type === 'section') {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T> | null = null;\n    let index = 0;\n    let size = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      // Only count sections and items when determining size so that\n      // loaders and separators in RAC/S2 don't influence the emptyState determination\n      if (node.type === 'section' || node.type === 'item') {\n        size++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n    this._size = size;\n    this.lastKey = last?.key ?? null;\n  }\n\n  *[Symbol.iterator](): IterableIterator<Node<T>> {\n    yield* this.iterable;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  getKeys(): IterableIterator<Key> {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key): Key | null {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey ?? null : null;\n  }\n\n  getKeyAfter(key: Key): Key | null {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey ?? null : null;\n  }\n\n  getFirstKey(): Key | null {\n    return this.firstKey;\n  }\n\n  getLastKey(): Key | null {\n    return this.lastKey;\n  }\n\n  getItem(key: Key): Node<T> | null {\n    return this.keyMap.get(key) ?? null;\n  }\n\n  at(idx: number): Node<T> | null {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key: Key): Iterable<Node<T>> {\n    let node = this.keyMap.get(key);\n    return node?.childNodes || [];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}