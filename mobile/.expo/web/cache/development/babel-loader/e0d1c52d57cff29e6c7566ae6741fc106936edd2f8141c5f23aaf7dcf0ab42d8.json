{"ast":null,"code":"var _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar $a7a032acae3ddda9$exports = require(\"./FocusScope.main.js\");\nvar $6RLDH$reactariautils = require(\"@react-aria/utils\");\nvar $6RLDH$react = require(\"react\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"useHasTabbableChild\", function () {\n  return $259c6413a286f2e6$export$eac1895992b9f3d6;\n});\nfunction $259c6413a286f2e6$export$eac1895992b9f3d6(ref, options) {\n  var isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;\n  var _ref = (0, $6RLDH$react.useState)(false),\n    _ref2 = _slicedToArray(_ref, 2),\n    hasTabbableChild = _ref2[0],\n    setHasTabbableChild = _ref2[1];\n  (0, $6RLDH$reactariautils.useLayoutEffect)(function () {\n    if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {\n      var update = function update() {\n        if (ref.current) {\n          var walker = (0, $a7a032acae3ddda9$exports.getFocusableTreeWalker)(ref.current, {\n            tabbable: true\n          });\n          setHasTabbableChild(!!walker.nextNode());\n        }\n      };\n      update();\n      var observer = new MutationObserver(update);\n      observer.observe(ref.current, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n        attributeFilter: ['tabIndex', 'disabled']\n      });\n      return function () {\n        observer.disconnect();\n      };\n    }\n  });\n  return isDisabled ? false : hasTabbableChild;\n}","map":{"version":3,"names":["$259c6413a286f2e6$export$eac1895992b9f3d6","ref","options","isDisabled","_ref","$6RLDH$react","useState","_ref2","_slicedToArray","hasTabbableChild","setHasTabbableChild","$6RLDH$reactariautils","useLayoutEffect","current","update","walker","$a7a032acae3ddda9$exports","getFocusableTreeWalker","tabbable","nextNode","observer","MutationObserver","observe","subtree","childList","attributes","attributeFilter","disconnect"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\focus\\dist\\packages\\@react-aria\\focus\\src\\useHasTabbableChild.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getFocusableTreeWalker} from './FocusScope';\nimport {RefObject} from '@react-types/shared';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {useState} from 'react';\n\ninterface AriaHasTabbableChildOptions {\n  isDisabled?: boolean\n}\n\n// This was created for a special empty case of a component that can have child or\n// be empty, like Collection/Virtualizer/Table/ListView/etc. When these components\n// are empty they can have a message with a tabbable element, which is like them\n// being not empty, when it comes to focus and tab order.\n\n/**\n * Returns whether an element has a tabbable child, and updates as children change.\n * @private\n */\nexport function useHasTabbableChild(ref: RefObject<Element | null>, options?: AriaHasTabbableChildOptions): boolean {\n  let isDisabled = options?.isDisabled;\n  let [hasTabbableChild, setHasTabbableChild] = useState(false);\n\n  useLayoutEffect(() => {\n    if (ref?.current && !isDisabled) {\n      let update = () => {\n        if (ref.current) {\n          let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n          setHasTabbableChild(!!walker.nextNode());\n        }\n      };\n\n      update();\n\n      // Update when new elements are inserted, or the tabIndex/disabled attribute updates.\n      let observer = new MutationObserver(update);\n      observer.observe(ref.current, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n        attributeFilter: ['tabIndex', 'disabled']\n      });\n\n      return () => {\n        // Disconnect mutation observer when a React update occurs on the top-level component\n        // so we update synchronously after re-rendering. Otherwise React will emit act warnings\n        // in tests since mutation observers fire asynchronously. The mutation observer is necessary\n        // so we also update if a child component re-renders and adds/removes something tabbable.\n        observer.disconnect();\n      };\n    }\n  });\n\n  return isDisabled ? false : hasTabbableChild;\n}\n"],"mappings":";;;;;;;;;;;;;;;AA8BO,SAASA,0CAAoBC,GAA8B,EAAEC,OAAqC;EACvG,IAAIC,UAAA,GAAaD,OAAA,aAAAA,OAAA,uBAAAA,OAAA,CAASC,UAAU;EACpC,IAAAC,IAAA,GAA8C,IAAAC,YAAA,CAAAC,QAAO,EAAE;IAAAC,KAAA,GAAAC,cAAA,CAAAJ,IAAA;IAAlDK,gBAAA,GAAAF,KAAA;IAAkBG,mBAAA,GAAAH,KAAA;EAEvB,IAAAI,qBAAA,CAAAC,eAAc,EAAE;IACd,IAAI,CAAAX,GAAA,aAAAA,GAAA,uBAAAA,GAAA,CAAKY,OAAO,KAAI,CAACV,UAAA,EAAY;MAC/B,IAAIW,MAAA,GAAS,SAATA,OAAA,EAAS;QACX,IAAIb,GAAA,CAAIY,OAAO,EAAE;UACf,IAAIE,MAAA,GAAS,IAAAC,yBAAA,CAAAC,sBAAqB,EAAEhB,GAAA,CAAIY,OAAO,EAAE;YAACK,QAAA,EAAU;UAAI;UAChER,mBAAA,CAAoB,CAAC,CAACK,MAAA,CAAOI,QAAQ;QACvC;MACF;MAEAL,MAAA;MAGA,IAAIM,QAAA,GAAW,IAAIC,gBAAA,CAAiBP,MAAA;MACpCM,QAAA,CAASE,OAAO,CAACrB,GAAA,CAAIY,OAAO,EAAE;QAC5BU,OAAA,EAAS;QACTC,SAAA,EAAW;QACXC,UAAA,EAAY;QACZC,eAAA,EAAiB,CAAC,YAAY;MAChC;MAEA,OAAO;QAKLN,QAAA,CAASO,UAAU;MACrB;IACF;EACF;EAEA,OAAOxB,UAAA,GAAa,QAAQM,gBAAA;AAC9B","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}