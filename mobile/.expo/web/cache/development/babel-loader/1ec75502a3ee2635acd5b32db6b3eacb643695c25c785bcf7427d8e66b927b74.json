{"ast":null,"code":"var _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar $21c847070f1f9569$exports = require(\"./Selection.main.js\");\nvar $ia6MY$reactstatelycollections = require(\"@react-stately/collections\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"SelectionManager\", function () {\n  return $8112da6fa5bbc322$export$6c8a5aaad13c9852;\n});\nvar $8112da6fa5bbc322$export$6c8a5aaad13c9852 = function () {\n  \"use strict\";\n\n  function $8112da6fa5bbc322$export$6c8a5aaad13c9852(collection, state, options) {\n    _classCallCheck(this, $8112da6fa5bbc322$export$6c8a5aaad13c9852);\n    this.collection = collection;\n    this.state = state;\n    var _options_allowsCellSelection;\n    this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n    this._isSelectAll = null;\n    this.layoutDelegate = (options === null || options === void 0 ? void 0 : options.layoutDelegate) || null;\n  }\n  return _createClass($8112da6fa5bbc322$export$6c8a5aaad13c9852, [{\n    key: \"selectionMode\",\n    get: function get() {\n      return this.state.selectionMode;\n    }\n  }, {\n    key: \"disallowEmptySelection\",\n    get: function get() {\n      return this.state.disallowEmptySelection;\n    }\n  }, {\n    key: \"selectionBehavior\",\n    get: function get() {\n      return this.state.selectionBehavior;\n    }\n  }, {\n    key: \"setSelectionBehavior\",\n    value: function setSelectionBehavior(selectionBehavior) {\n      this.state.setSelectionBehavior(selectionBehavior);\n    }\n  }, {\n    key: \"isFocused\",\n    get: function get() {\n      return this.state.isFocused;\n    }\n  }, {\n    key: \"setFocused\",\n    value: function setFocused(isFocused) {\n      this.state.setFocused(isFocused);\n    }\n  }, {\n    key: \"focusedKey\",\n    get: function get() {\n      return this.state.focusedKey;\n    }\n  }, {\n    key: \"childFocusStrategy\",\n    get: function get() {\n      return this.state.childFocusStrategy;\n    }\n  }, {\n    key: \"setFocusedKey\",\n    value: function setFocusedKey(key, childFocusStrategy) {\n      if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }, {\n    key: \"selectedKeys\",\n    get: function get() {\n      return this.state.selectedKeys === 'all' ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n  }, {\n    key: \"rawSelection\",\n    get: function get() {\n      return this.state.selectedKeys;\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected(key) {\n      if (this.state.selectionMode === 'none') return false;\n      var mappedKey = this.getKey(key);\n      if (mappedKey == null) return false;\n      return this.state.selectedKeys === 'all' ? this.canSelectItem(mappedKey) : this.state.selectedKeys.has(mappedKey);\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n    }\n  }, {\n    key: \"isSelectAll\",\n    get: function get() {\n      if (this.isEmpty) return false;\n      if (this.state.selectedKeys === 'all') return true;\n      if (this._isSelectAll != null) return this._isSelectAll;\n      var allKeys = this.getSelectAllKeys();\n      var selectedKeys = this.state.selectedKeys;\n      this._isSelectAll = allKeys.every(function (k) {\n        return selectedKeys.has(k);\n      });\n      return this._isSelectAll;\n    }\n  }, {\n    key: \"firstSelectedKey\",\n    get: function get() {\n      var first = null;\n      for (var key of this.state.selectedKeys) {\n        var item = this.collection.getItem(key);\n        if (!first || item && (0, $ia6MY$reactstatelycollections.compareNodeOrder)(this.collection, item, first) < 0) first = item;\n      }\n      var _first_key;\n      return (_first_key = first === null || first === void 0 ? void 0 : first.key) !== null && _first_key !== void 0 ? _first_key : null;\n    }\n  }, {\n    key: \"lastSelectedKey\",\n    get: function get() {\n      var last = null;\n      for (var key of this.state.selectedKeys) {\n        var item = this.collection.getItem(key);\n        if (!last || item && (0, $ia6MY$reactstatelycollections.compareNodeOrder)(this.collection, item, last) > 0) last = item;\n      }\n      var _last_key;\n      return (_last_key = last === null || last === void 0 ? void 0 : last.key) !== null && _last_key !== void 0 ? _last_key : null;\n    }\n  }, {\n    key: \"disabledKeys\",\n    get: function get() {\n      return this.state.disabledKeys;\n    }\n  }, {\n    key: \"disabledBehavior\",\n    get: function get() {\n      return this.state.disabledBehavior;\n    }\n  }, {\n    key: \"extendSelection\",\n    value: function extendSelection(toKey) {\n      if (this.selectionMode === 'none') return;\n      if (this.selectionMode === 'single') {\n        this.replaceSelection(toKey);\n        return;\n      }\n      var mappedToKey = this.getKey(toKey);\n      if (mappedToKey == null) return;\n      var selection;\n      if (this.state.selectedKeys === 'all') selection = new (0, $21c847070f1f9569$exports.Selection)([mappedToKey], mappedToKey, mappedToKey);else {\n        var selectedKeys = this.state.selectedKeys;\n        var _selectedKeys_anchorKey;\n        var anchorKey = (_selectedKeys_anchorKey = selectedKeys.anchorKey) !== null && _selectedKeys_anchorKey !== void 0 ? _selectedKeys_anchorKey : mappedToKey;\n        selection = new (0, $21c847070f1f9569$exports.Selection)(selectedKeys, anchorKey, mappedToKey);\n        var _selectedKeys_currentKey;\n        for (var key of this.getKeyRange(anchorKey, (_selectedKeys_currentKey = selectedKeys.currentKey) !== null && _selectedKeys_currentKey !== void 0 ? _selectedKeys_currentKey : mappedToKey)) selection.delete(key);\n        for (var _key of this.getKeyRange(mappedToKey, anchorKey)) if (this.canSelectItem(_key)) selection.add(_key);\n      }\n      this.state.setSelectedKeys(selection);\n    }\n  }, {\n    key: \"getKeyRange\",\n    value: function getKeyRange(from, to) {\n      var fromItem = this.collection.getItem(from);\n      var toItem = this.collection.getItem(to);\n      if (fromItem && toItem) {\n        if ((0, $ia6MY$reactstatelycollections.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n        return this.getKeyRangeInternal(to, from);\n      }\n      return [];\n    }\n  }, {\n    key: \"getKeyRangeInternal\",\n    value: function getKeyRangeInternal(from, to) {\n      var _this_layoutDelegate;\n      if ((_this_layoutDelegate = this.layoutDelegate) === null || _this_layoutDelegate === void 0 ? void 0 : _this_layoutDelegate.getKeyRange) return this.layoutDelegate.getKeyRange(from, to);\n      var keys = [];\n      var key = from;\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item && (item.type === 'item' || item.type === 'cell' && this.allowsCellSelection)) keys.push(key);\n        if (key === to) return keys;\n        key = this.collection.getKeyAfter(key);\n      }\n      return [];\n    }\n  }, {\n    key: \"getKey\",\n    value: function getKey(key) {\n      var item = this.collection.getItem(key);\n      if (!item) return key;\n      if (item.type === 'cell' && this.allowsCellSelection) return key;\n      while (item && item.type !== 'item' && item.parentKey != null) item = this.collection.getItem(item.parentKey);\n      if (!item || item.type !== 'item') return null;\n      return item.key;\n    }\n  }, {\n    key: \"toggleSelection\",\n    value: function toggleSelection(key) {\n      if (this.selectionMode === 'none') return;\n      if (this.selectionMode === 'single' && !this.isSelected(key)) {\n        this.replaceSelection(key);\n        return;\n      }\n      var mappedKey = this.getKey(key);\n      if (mappedKey == null) return;\n      var keys = new (0, $21c847070f1f9569$exports.Selection)(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n      if (keys.has(mappedKey)) keys.delete(mappedKey);else if (this.canSelectItem(mappedKey)) {\n        keys.add(mappedKey);\n        keys.anchorKey = mappedKey;\n        keys.currentKey = mappedKey;\n      }\n      if (this.disallowEmptySelection && keys.size === 0) return;\n      this.state.setSelectedKeys(keys);\n    }\n  }, {\n    key: \"replaceSelection\",\n    value: function replaceSelection(key) {\n      if (this.selectionMode === 'none') return;\n      var mappedKey = this.getKey(key);\n      if (mappedKey == null) return;\n      var selection = this.canSelectItem(mappedKey) ? new (0, $21c847070f1f9569$exports.Selection)([mappedKey], mappedKey, mappedKey) : new (0, $21c847070f1f9569$exports.Selection)();\n      this.state.setSelectedKeys(selection);\n    }\n  }, {\n    key: \"setSelectedKeys\",\n    value: function setSelectedKeys(keys) {\n      if (this.selectionMode === 'none') return;\n      var selection = new (0, $21c847070f1f9569$exports.Selection)();\n      for (var key of keys) {\n        var mappedKey = this.getKey(key);\n        if (mappedKey != null) {\n          selection.add(mappedKey);\n          if (this.selectionMode === 'single') break;\n        }\n      }\n      this.state.setSelectedKeys(selection);\n    }\n  }, {\n    key: \"getSelectAllKeys\",\n    value: function getSelectAllKeys() {\n      var _this = this;\n      var keys = [];\n      var _addKeys = function addKeys(key) {\n        while (key != null) {\n          if (_this.canSelectItem(key)) {\n            var _getFirstItem;\n            var item = _this.collection.getItem(key);\n            if ((item === null || item === void 0 ? void 0 : item.type) === 'item') keys.push(key);\n            var _getFirstItem_key;\n            if ((item === null || item === void 0 ? void 0 : item.hasChildNodes) && (_this.allowsCellSelection || item.type !== 'item')) _addKeys((_getFirstItem_key = (_getFirstItem = (0, $ia6MY$reactstatelycollections.getFirstItem)((0, $ia6MY$reactstatelycollections.getChildNodes)(item, _this.collection))) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key) !== null && _getFirstItem_key !== void 0 ? _getFirstItem_key : null);\n          }\n          key = _this.collection.getKeyAfter(key);\n        }\n      };\n      _addKeys(this.collection.getFirstKey());\n      return keys;\n    }\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      if (!this.isSelectAll && this.selectionMode === 'multiple') this.state.setSelectedKeys('all');\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $21c847070f1f9569$exports.Selection)());\n    }\n  }, {\n    key: \"toggleSelectAll\",\n    value: function toggleSelectAll() {\n      if (this.isSelectAll) this.clearSelection();else this.selectAll();\n    }\n  }, {\n    key: \"select\",\n    value: function select(key, e) {\n      if (this.selectionMode === 'none') return;\n      if (this.selectionMode === 'single') {\n        if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);else this.replaceSelection(key);\n      } else if (this.selectionBehavior === 'toggle' || e && (e.pointerType === 'touch' || e.pointerType === 'virtual')) this.toggleSelection(key);else this.replaceSelection(key);\n    }\n  }, {\n    key: \"isSelectionEqual\",\n    value: function isSelectionEqual(selection) {\n      if (selection === this.state.selectedKeys) return true;\n      var selectedKeys = this.selectedKeys;\n      if (selection.size !== selectedKeys.size) return false;\n      for (var key of selection) {\n        if (!selectedKeys.has(key)) return false;\n      }\n      for (var _key2 of selectedKeys) {\n        if (!selection.has(_key2)) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"canSelectItem\",\n    value: function canSelectItem(key) {\n      var _item_props;\n      if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) return false;\n      var item = this.collection.getItem(key);\n      if (!item || (item === null || item === void 0 ? void 0 : (_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || item.type === 'cell' && !this.allowsCellSelection) return false;\n      return true;\n    }\n  }, {\n    key: \"isDisabled\",\n    value: function isDisabled(key) {\n      var _this_collection_getItem_props, _this_collection_getItem;\n      return this.state.disabledBehavior === 'all' && (this.state.disabledKeys.has(key) || !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.isDisabled));\n    }\n  }, {\n    key: \"isLink\",\n    value: function isLink(key) {\n      var _this_collection_getItem_props, _this_collection_getItem;\n      return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n    }\n  }, {\n    key: \"getItemProps\",\n    value: function getItemProps(key) {\n      var _this_collection_getItem;\n      return (_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : _this_collection_getItem.props;\n    }\n  }, {\n    key: \"withCollection\",\n    value: function withCollection(collection) {\n      return new $8112da6fa5bbc322$export$6c8a5aaad13c9852(collection, this.state, {\n        allowsCellSelection: this.allowsCellSelection,\n        layoutDelegate: this.layoutDelegate || undefined\n      });\n    }\n  }]);\n}();","map":{"version":3,"names":["$8112da6fa5bbc322$export$6c8a5aaad13c9852","collection","state","options","_classCallCheck","_options_allowsCellSelection","allowsCellSelection","_isSelectAll","layoutDelegate","_createClass","key","get","selectionMode","disallowEmptySelection","selectionBehavior","value","setSelectionBehavior","isFocused","setFocused","focusedKey","childFocusStrategy","setFocusedKey","getItem","selectedKeys","Set","getSelectAllKeys","isSelected","mappedKey","getKey","canSelectItem","has","size","isEmpty","allKeys","every","k","first","item","$ia6MY$reactstatelycollections","compareNodeOrder","_first_key","last","_last_key","disabledKeys","disabledBehavior","extendSelection","toKey","replaceSelection","mappedToKey","selection","$21c847070f1f9569$exports","Selection","_selectedKeys_anchorKey","anchorKey","_selectedKeys_currentKey","getKeyRange","currentKey","delete","add","setSelectedKeys","from","to","fromItem","toItem","getKeyRangeInternal","_this_layoutDelegate","keys","type","push","getKeyAfter","parentKey","toggleSelection","_this","addKeys","_getFirstItem","_getFirstItem_key","hasChildNodes","getFirstItem","getChildNodes","getFirstKey","selectAll","isSelectAll","clearSelection","toggleSelectAll","select","e","pointerType","isSelectionEqual","_item_props","props","isDisabled","_this_collection_getItem_props","_this_collection_getItem","isLink","href","getItemProps","withCollection","undefined"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\SelectionManager.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection, DisabledBehavior,\n  FocusStrategy,\n  Selection as ISelection,\n  Key,\n  LayoutDelegate,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {compareNodeOrder, getChildNodes, getFirstItem} from '@react-stately/collections';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean,\n  layoutDelegate?: LayoutDelegate\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean | null;\n  private layoutDelegate: LayoutDelegate | null;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n    this.layoutDelegate = options?.layoutDelegate || null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior): void {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean): void {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key | null {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy | null {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key | null, childFocusStrategy?: FocusStrategy): void {\n    if (key == null || this.collection.getItem(key)) {\n      this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key): boolean {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    let mappedKey = this.getKey(key);\n    if (mappedKey == null) {\n      return false;\n    }\n    return this.state.selectedKeys === 'all'\n      ? this.canSelectItem(mappedKey)\n      : this.state.selectedKeys.has(mappedKey);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || (item && compareNodeOrder(this.collection, item, first) < 0)) {\n        first = item;\n      }\n    }\n\n    return first?.key ?? null;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || (item && compareNodeOrder(this.collection, item, last) > 0)) {\n        last = item;\n      }\n    }\n\n    return last?.key ?? null;\n  }\n\n  get disabledKeys(): Set<Key> {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior(): DisabledBehavior {\n    return this.state.disabledBehavior;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key): void {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    let mappedToKey = this.getKey(toKey);\n    if (mappedToKey == null) {\n      return;\n    }\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([mappedToKey], mappedToKey, mappedToKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey ?? mappedToKey;\n      selection = new Selection(selectedKeys, anchorKey, mappedToKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey ?? mappedToKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(mappedToKey, anchorKey)) {\n        if (this.canSelectItem(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (compareNodeOrder(this.collection, fromItem, toItem) <= 0) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    if (this.layoutDelegate?.getKeyRange) {\n      return this.layoutDelegate.getKeyRange(from, to);\n    }\n\n    let keys: Key[] = [];\n    let key: Key | null = from;\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item && (item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection))) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // ¯\\_(ツ)_/¯\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item && item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key): void {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    let mappedKey = this.getKey(key);\n    if (mappedKey == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(mappedKey)) {\n      keys.delete(mappedKey);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else if (this.canSelectItem(mappedKey)) {\n      keys.add(mappedKey);\n      keys.anchorKey = mappedKey;\n      keys.currentKey = mappedKey;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key): void {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let mappedKey = this.getKey(key);\n    if (mappedKey == null) {\n      return;\n    }\n\n    let selection = this.canSelectItem(mappedKey)\n      ? new Selection([mappedKey], mappedKey, mappedKey)\n      : new Selection();\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>): void {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      let mappedKey = this.getKey(key);\n      if (mappedKey != null) {\n        selection.add(mappedKey);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key | null) => {\n      while (key != null) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item?.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item?.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys(getFirstItem(getChildNodes(item, this.collection))?.key ?? null);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll(): void {\n    if (!this.isSelectAll && this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection(): void {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll(): void {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent): void {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>): boolean {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key): boolean {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || item?.props?.isDisabled || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isDisabled(key: Key): boolean {\n    return this.state.disabledBehavior === 'all' && (this.state.disabledKeys.has(key) || !!this.collection.getItem(key)?.props?.isDisabled);\n  }\n\n  isLink(key: Key): boolean {\n    return !!this.collection.getItem(key)?.props?.href;\n  }\n\n  getItemProps(key: Key): any {\n    return this.collection.getItem(key)?.props;\n  }\n\n  withCollection(collection: Collection<Node<unknown>>): SelectionManager {\n    return new SelectionManager(collection, this.state, {\n      allowsCellSelection: this.allowsCellSelection,\n      layoutDelegate: this.layoutDelegate || undefined\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}