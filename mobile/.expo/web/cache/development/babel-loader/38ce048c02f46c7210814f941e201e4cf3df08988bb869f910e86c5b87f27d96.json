{"ast":null,"code":"var $59kHH$reactariautils = require(\"@react-aria/utils\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"usePreventScroll\", function () {\n  return $5c2f5cd01815d369$export$ee0f7cc6afcd1c18;\n});\nvar $5c2f5cd01815d369$var$visualViewport = typeof document !== 'undefined' && window.visualViewport;\nvar $5c2f5cd01815d369$var$preventScrollCount = 0;\nvar $5c2f5cd01815d369$var$restore;\nfunction $5c2f5cd01815d369$export$ee0f7cc6afcd1c18() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var isDisabled = options.isDisabled;\n  (0, $59kHH$reactariautils.useLayoutEffect)(function () {\n    if (isDisabled) return;\n    $5c2f5cd01815d369$var$preventScrollCount++;\n    if ($5c2f5cd01815d369$var$preventScrollCount === 1) {\n      if ((0, $59kHH$reactariautils.isIOS)()) $5c2f5cd01815d369$var$restore = $5c2f5cd01815d369$var$preventScrollMobileSafari();else $5c2f5cd01815d369$var$restore = $5c2f5cd01815d369$var$preventScrollStandard();\n    }\n    return function () {\n      $5c2f5cd01815d369$var$preventScrollCount--;\n      if ($5c2f5cd01815d369$var$preventScrollCount === 0) $5c2f5cd01815d369$var$restore();\n    };\n  }, [isDisabled]);\n}\nfunction $5c2f5cd01815d369$var$preventScrollStandard() {\n  var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  return (0, $59kHH$reactariautils.chain)(scrollbarWidth > 0 && ('scrollbarGutter' in document.documentElement.style ? $5c2f5cd01815d369$var$setStyle(document.documentElement, 'scrollbarGutter', 'stable') : $5c2f5cd01815d369$var$setStyle(document.documentElement, 'paddingRight', `${scrollbarWidth}px`)), $5c2f5cd01815d369$var$setStyle(document.documentElement, 'overflow', 'hidden'));\n}\nfunction $5c2f5cd01815d369$var$preventScrollMobileSafari() {\n  var scrollable;\n  var allowTouchMove = false;\n  var onTouchStart = function onTouchStart(e) {\n    var target = e.target;\n    scrollable = (0, $59kHH$reactariautils.isScrollable)(target) ? target : (0, $59kHH$reactariautils.getScrollParent)(target, true);\n    allowTouchMove = false;\n    var selection = target.ownerDocument.defaultView.getSelection();\n    if (selection && !selection.isCollapsed && selection.containsNode(target, true)) allowTouchMove = true;\n    if ('selectionStart' in target && 'selectionEnd' in target && target.selectionStart < target.selectionEnd && target.ownerDocument.activeElement === target) allowTouchMove = true;\n  };\n  var style = document.createElement('style');\n  style.textContent = `\n@layer {\n  * {\n    overscroll-behavior: contain;\n  }\n}`.trim();\n  document.head.prepend(style);\n  var onTouchMove = function onTouchMove(e) {\n    if (e.touches.length === 2 || allowTouchMove) return;\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) e.preventDefault();\n  };\n  var onBlur = function onBlur(e) {\n    var target = e.target;\n    var relatedTarget = e.relatedTarget;\n    if (relatedTarget && (0, $59kHH$reactariautils.willOpenKeyboard)(relatedTarget)) {\n      relatedTarget.focus({\n        preventScroll: true\n      });\n      $5c2f5cd01815d369$var$scrollIntoViewWhenReady(relatedTarget, (0, $59kHH$reactariautils.willOpenKeyboard)(target));\n    } else if (!relatedTarget) {\n      var _target_parentElement;\n      var focusable = (_target_parentElement = target.parentElement) === null || _target_parentElement === void 0 ? void 0 : _target_parentElement.closest('[tabindex]');\n      focusable === null || focusable === void 0 ? void 0 : focusable.focus({\n        preventScroll: true\n      });\n    }\n  };\n  var focus = HTMLElement.prototype.focus;\n  HTMLElement.prototype.focus = function (opts) {\n    var wasKeyboardVisible = document.activeElement != null && (0, $59kHH$reactariautils.willOpenKeyboard)(document.activeElement);\n    focus.call(this, Object.assign({}, opts, {\n      preventScroll: true\n    }));\n    if (!opts || !opts.preventScroll) $5c2f5cd01815d369$var$scrollIntoViewWhenReady(this, wasKeyboardVisible);\n  };\n  var removeEvents = (0, $59kHH$reactariautils.chain)($5c2f5cd01815d369$var$addEvent(document, 'touchstart', onTouchStart, {\n    passive: false,\n    capture: true\n  }), $5c2f5cd01815d369$var$addEvent(document, 'touchmove', onTouchMove, {\n    passive: false,\n    capture: true\n  }), $5c2f5cd01815d369$var$addEvent(document, 'blur', onBlur, true));\n  return function () {\n    removeEvents();\n    style.remove();\n    HTMLElement.prototype.focus = focus;\n  };\n}\nfunction $5c2f5cd01815d369$var$setStyle(element, style, value) {\n  var cur = element.style[style];\n  element.style[style] = value;\n  return function () {\n    element.style[style] = cur;\n  };\n}\nfunction $5c2f5cd01815d369$var$addEvent(target, event, handler, options) {\n  target.addEventListener(event, handler, options);\n  return function () {\n    target.removeEventListener(event, handler, options);\n  };\n}\nfunction $5c2f5cd01815d369$var$scrollIntoViewWhenReady(target, wasKeyboardVisible) {\n  if (wasKeyboardVisible || !$5c2f5cd01815d369$var$visualViewport) $5c2f5cd01815d369$var$scrollIntoView(target);else $5c2f5cd01815d369$var$visualViewport.addEventListener('resize', function () {\n      return $5c2f5cd01815d369$var$scrollIntoView(target);\n    }, {\n      once: true\n    });\n}\nfunction $5c2f5cd01815d369$var$scrollIntoView(target) {\n  var root = document.scrollingElement || document.documentElement;\n  var nextTarget = target;\n  while (nextTarget && nextTarget !== root) {\n    var scrollable = (0, $59kHH$reactariautils.getScrollParent)(nextTarget);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== nextTarget) {\n      var scrollableRect = scrollable.getBoundingClientRect();\n      var targetRect = nextTarget.getBoundingClientRect();\n      if (targetRect.top < scrollableRect.top || targetRect.bottom > scrollableRect.top + nextTarget.clientHeight) {\n        var bottom = scrollableRect.bottom;\n        if ($5c2f5cd01815d369$var$visualViewport) bottom = Math.min(bottom, $5c2f5cd01815d369$var$visualViewport.offsetTop + $5c2f5cd01815d369$var$visualViewport.height);\n        var adjustment = targetRect.top - scrollableRect.top - ((bottom - scrollableRect.top) / 2 - targetRect.height / 2);\n        scrollable.scrollTo({\n          top: Math.max(0, Math.min(scrollable.scrollHeight - scrollable.clientHeight, scrollable.scrollTop + adjustment)),\n          behavior: 'smooth'\n        });\n      }\n    }\n    nextTarget = scrollable.parentElement;\n  }\n}","map":{"version":3,"names":["$5c2f5cd01815d369$var$visualViewport","document","window","visualViewport","$5c2f5cd01815d369$var$preventScrollCount","$5c2f5cd01815d369$var$restore","$5c2f5cd01815d369$export$ee0f7cc6afcd1c18","options","arguments","length","undefined","isDisabled","$59kHH$reactariautils","useLayoutEffect","isIOS","$5c2f5cd01815d369$var$preventScrollMobileSafari","$5c2f5cd01815d369$var$preventScrollStandard","scrollbarWidth","innerWidth","documentElement","clientWidth","chain","style","$5c2f5cd01815d369$var$setStyle","scrollable","allowTouchMove","onTouchStart","e","target","isScrollable","getScrollParent","selection","ownerDocument","defaultView","getSelection","isCollapsed","containsNode","selectionStart","selectionEnd","activeElement","createElement","textContent","trim","head","prepend","onTouchMove","touches","body","preventDefault","scrollHeight","clientHeight","scrollWidth","onBlur","relatedTarget","willOpenKeyboard","focus","preventScroll","$5c2f5cd01815d369$var$scrollIntoViewWhenReady","_target_parentElement","focusable","parentElement","closest","HTMLElement","prototype","opts","wasKeyboardVisible","call","Object","assign","removeEvents","$5c2f5cd01815d369$var$addEvent","passive","capture","remove","element","value","cur","event","handler","addEventListener","removeEventListener","$5c2f5cd01815d369$var$scrollIntoView","once","root","scrollingElement","nextTarget","scrollableRect","getBoundingClientRect","targetRect","top","bottom","Math","min","offsetTop","height","adjustment","scrollTo","max","scrollTop","behavior"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\usePreventScroll.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain, getScrollParent, isIOS, isScrollable, useLayoutEffect, willOpenKeyboard} from '@react-aria/utils';\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean\n}\n\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}): void {\n  let {isDisabled} = options;\n\n  useLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  return chain(\n    scrollbarWidth > 0 &&\n      // Use scrollbar-gutter when supported because it also works for fixed positioned elements.\n      ('scrollbarGutter' in document.documentElement.style\n        ? setStyle(document.documentElement, 'scrollbarGutter', 'stable')\n        : setStyle(document.documentElement, 'paddingRight', `${scrollbarWidth}px`)),\n    setStyle(document.documentElement, 'overflow', 'hidden')\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event. This is best effort: we can't prevent default when pinch\n//    zooming or when an element contains text selection, which may allow scrolling in some cases.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focus moves to an input, create an off screen input and focus that temporarily. This prevents \n//    Safari from scrolling the page. After a small delay, focus the real input and scroll it into view\n//    ourselves, without scrolling the whole page.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element;\n  let allowTouchMove = false;\n  let onTouchStart = (e: TouchEvent) => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    let target = e.target as Element;\n    scrollable = isScrollable(target) ? target : getScrollParent(target, true);\n    allowTouchMove = false;\n    \n    // If the target is selected, don't preventDefault in touchmove to allow user to adjust selection.\n    let selection = target.ownerDocument.defaultView!.getSelection();\n    if (selection && !selection.isCollapsed && selection.containsNode(target, true)) {\n      allowTouchMove = true;\n    }\n\n    // If this is a focused input element with a selected range, allow user to drag the selection handles.\n    if (\n      'selectionStart' in target && \n      'selectionEnd' in target &&\n      (target.selectionStart as number) < (target.selectionEnd as number) &&\n      target.ownerDocument.activeElement === target\n    ) {\n      allowTouchMove = true;\n    }\n  };\n\n  // Prevent scrolling up when at the top and scrolling down when at the bottom\n  // of a nested scrollable area, otherwise mobile Safari will start scrolling\n  // the window instead.\n  // This must be applied before the touchstart event as of iOS 26, so inject it as a <style> element.\n  let style = document.createElement('style');\n  style.textContent = `\n@layer {\n  * {\n    overscroll-behavior: contain;\n  }\n}`.trim();\n  document.head.prepend(style);\n\n  let onTouchMove = (e: TouchEvent) => {\n    // Allow pinch-zooming.\n    if (e.touches.length === 2 || allowTouchMove) {\n      return;\n    }\n\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) {\n      e.preventDefault();\n    }\n  };\n\n  let onBlur = (e: FocusEvent) => {\n    let target = e.target as HTMLElement;\n    let relatedTarget = e.relatedTarget as HTMLElement | null;\n    if (relatedTarget && willOpenKeyboard(relatedTarget)) {\n      // Focus without scrolling the whole page, and then scroll into view manually.\n      relatedTarget.focus({preventScroll: true});\n      scrollIntoViewWhenReady(relatedTarget, willOpenKeyboard(target));\n    } else if (!relatedTarget) {\n      // When tapping the Done button on the keyboard, focus moves to the body.\n      // FocusScope will then restore focus back to the input. Later when tapping\n      // the same input again, it is already focused, so no blur event will fire,\n      // resulting in the flow above never running and Safari's native scrolling occurring.\n      // Instead, move focus to the parent focusable element (e.g. the dialog).\n      let focusable = target.parentElement?.closest('[tabindex]') as HTMLElement | null;\n      focusable?.focus({preventScroll: true});\n    }\n  };\n\n  // Override programmatic focus to scroll into view without scrolling the whole page.\n  let focus = HTMLElement.prototype.focus;\n  HTMLElement.prototype.focus = function (opts) {\n    // Track whether the keyboard was already visible before.\n    let wasKeyboardVisible = document.activeElement != null && willOpenKeyboard(document.activeElement);\n\n    // Focus the element without scrolling the page.\n    focus.call(this, {...opts, preventScroll: true});\n\n    if (!opts || !opts.preventScroll) {\n      scrollIntoViewWhenReady(this, wasKeyboardVisible);\n    }\n  };\n\n  let removeEvents = chain(\n    addEvent(document, 'touchstart', onTouchStart, {passive: false, capture: true}),\n    addEvent(document, 'touchmove', onTouchMove, {passive: false, capture: true}),\n    addEvent(document, 'blur', onBlur, true)\n  );\n\n  return () => {\n    removeEvents();\n    style.remove();\n    HTMLElement.prototype.focus = focus;\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: HTMLElement, style: string, value: string) {\n  let cur = element.style[style];\n  element.style[style] = value;\n\n  return () => {\n    element.style[style] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: Document | Window,\n  event: K,\n  handler: (this: Document | Window, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  // internal function, so it's ok to ignore the difficult to fix type error\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoViewWhenReady(target: Element, wasKeyboardVisible: boolean) {\n  if (wasKeyboardVisible || !visualViewport) {\n    // If the keyboard was already visible, scroll the target into view immediately.\n    scrollIntoView(target);\n  } else {\n    // Otherwise, wait for the visual viewport to resize before scrolling so we can\n    // measure the correct position to scroll to.\n    visualViewport.addEventListener('resize', () => scrollIntoView(target), {once: true});\n  }\n}\n\nfunction scrollIntoView(target: Element) {\n  let root = document.scrollingElement || document.documentElement;\n  let nextTarget: Element | null = target;\n  while (nextTarget && nextTarget !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = getScrollParent(nextTarget);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== nextTarget) {\n      let scrollableRect = scrollable.getBoundingClientRect();\n      let targetRect = nextTarget.getBoundingClientRect();\n      if (targetRect.top < scrollableRect.top || targetRect.bottom > scrollableRect.top + nextTarget.clientHeight) {\n        let bottom = scrollableRect.bottom;\n        if (visualViewport) {\n          bottom = Math.min(bottom, visualViewport.offsetTop + visualViewport.height);\n        }\n\n        // Center within the viewport.\n        let adjustment = (targetRect.top - scrollableRect.top) - ((bottom - scrollableRect.top) / 2 - targetRect.height / 2);\n        scrollable.scrollTo({\n          // Clamp to the valid range to prevent over-scrolling.\n          top: Math.max(0, Math.min(scrollable.scrollHeight - scrollable.clientHeight, scrollable.scrollTop + adjustment)),\n          behavior: 'smooth'\n        });\n      }\n    }\n\n    nextTarget = scrollable.parentElement;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}