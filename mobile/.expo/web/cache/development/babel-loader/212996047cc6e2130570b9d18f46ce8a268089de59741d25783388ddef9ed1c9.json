{"ast":null,"code":"var _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar $5935ba4d7da2c103$exports = require(\"./calculatePosition.main.js\");\nvar $9a8aa1b0b336ea3a$exports = require(\"./useCloseOnScroll.main.js\");\nvar $6TXnl$react = require(\"react\");\nvar $6TXnl$reactariautils = require(\"@react-aria/utils\");\nvar $6TXnl$reactariai18n = require(\"@react-aria/i18n\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"useOverlayPosition\", function () {\n  return $cd94b4896dd97759$export$d39e1813b3bdd0e1;\n});\nvar $cd94b4896dd97759$var$visualViewport = typeof document !== 'undefined' ? window.visualViewport : null;\nfunction $cd94b4896dd97759$export$d39e1813b3bdd0e1(props) {\n  var _ref = (0, $6TXnl$reactariai18n.useLocale)(),\n    direction = _ref.direction;\n  var arrowSize = props.arrowSize,\n    targetRef = props.targetRef,\n    overlayRef = props.overlayRef,\n    arrowRef = props.arrowRef,\n    _props$scrollRef = props.scrollRef,\n    scrollRef = _props$scrollRef === void 0 ? overlayRef : _props$scrollRef,\n    _props$placement = props.placement,\n    placement = _props$placement === void 0 ? 'bottom' : _props$placement,\n    _props$containerPaddi = props.containerPadding,\n    containerPadding = _props$containerPaddi === void 0 ? 12 : _props$containerPaddi,\n    _props$shouldFlip = props.shouldFlip,\n    shouldFlip = _props$shouldFlip === void 0 ? true : _props$shouldFlip,\n    _props$boundaryElemen = props.boundaryElement,\n    boundaryElement = _props$boundaryElemen === void 0 ? typeof document !== 'undefined' ? document.body : null : _props$boundaryElemen,\n    _props$offset = props.offset,\n    offset = _props$offset === void 0 ? 0 : _props$offset,\n    _props$crossOffset = props.crossOffset,\n    crossOffset = _props$crossOffset === void 0 ? 0 : _props$crossOffset,\n    _props$shouldUpdatePo = props.shouldUpdatePosition,\n    shouldUpdatePosition = _props$shouldUpdatePo === void 0 ? true : _props$shouldUpdatePo,\n    _props$isOpen = props.isOpen,\n    isOpen = _props$isOpen === void 0 ? true : _props$isOpen,\n    onClose = props.onClose,\n    maxHeight = props.maxHeight,\n    _props$arrowBoundaryO = props.arrowBoundaryOffset,\n    arrowBoundaryOffset = _props$arrowBoundaryO === void 0 ? 0 : _props$arrowBoundaryO;\n  var _ref2 = (0, $6TXnl$react.useState)(null),\n    _ref3 = _slicedToArray(_ref2, 2),\n    position = _ref3[0],\n    setPosition = _ref3[1];\n  var deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, arrowRef === null || arrowRef === void 0 ? void 0 : arrowRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, maxHeight, arrowBoundaryOffset, arrowSize];\n  var lastScale = (0, $6TXnl$react.useRef)($cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.scale);\n  (0, $6TXnl$react.useEffect)(function () {\n    if (isOpen) lastScale.current = $cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.scale;\n  }, [isOpen]);\n  var updatePosition = (0, $6TXnl$react.useCallback)(function () {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !boundaryElement) return;\n    if (($cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.scale) !== lastScale.current) return;\n    var anchor = null;\n    if (scrollRef.current && scrollRef.current.contains(document.activeElement)) {\n      var _document_activeElement;\n      var anchorRect = (_document_activeElement = document.activeElement) === null || _document_activeElement === void 0 ? void 0 : _document_activeElement.getBoundingClientRect();\n      var scrollRect = scrollRef.current.getBoundingClientRect();\n      var _anchorRect_top;\n      anchor = {\n        type: 'top',\n        offset: ((_anchorRect_top = anchorRect === null || anchorRect === void 0 ? void 0 : anchorRect.top) !== null && _anchorRect_top !== void 0 ? _anchorRect_top : 0) - scrollRect.top\n      };\n      if (anchor.offset > scrollRect.height / 2) {\n        anchor.type = 'bottom';\n        var _anchorRect_bottom;\n        anchor.offset = ((_anchorRect_bottom = anchorRect === null || anchorRect === void 0 ? void 0 : anchorRect.bottom) !== null && _anchorRect_bottom !== void 0 ? _anchorRect_bottom : 0) - scrollRect.bottom;\n      }\n    }\n    var overlay = overlayRef.current;\n    if (!maxHeight && overlayRef.current) {\n      var _window_visualViewport;\n      overlay.style.top = '0px';\n      overlay.style.bottom = '';\n      var _window_visualViewport_height;\n      overlay.style.maxHeight = ((_window_visualViewport_height = (_window_visualViewport = window.visualViewport) === null || _window_visualViewport === void 0 ? void 0 : _window_visualViewport.height) !== null && _window_visualViewport_height !== void 0 ? _window_visualViewport_height : window.innerHeight) + 'px';\n    }\n    var position = (0, $5935ba4d7da2c103$exports.calculatePosition)({\n      placement: $cd94b4896dd97759$var$translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current || overlayRef.current,\n      padding: containerPadding,\n      shouldFlip: shouldFlip,\n      boundaryElement: boundaryElement,\n      offset: offset,\n      crossOffset: crossOffset,\n      maxHeight: maxHeight,\n      arrowSize: arrowSize !== null && arrowSize !== void 0 ? arrowSize : (arrowRef === null || arrowRef === void 0 ? void 0 : arrowRef.current) ? (0, $5935ba4d7da2c103$exports.getRect)(arrowRef.current, true).width : 0,\n      arrowBoundaryOffset: arrowBoundaryOffset\n    });\n    if (!position.position) return;\n    overlay.style.top = '';\n    overlay.style.bottom = '';\n    overlay.style.left = '';\n    overlay.style.right = '';\n    Object.keys(position.position).forEach(function (key) {\n      return overlay.style[key] = position.position[key] + 'px';\n    });\n    overlay.style.maxHeight = position.maxHeight != null ? position.maxHeight + 'px' : '';\n    if (anchor && document.activeElement && scrollRef.current) {\n      var _anchorRect = document.activeElement.getBoundingClientRect();\n      var _scrollRect = scrollRef.current.getBoundingClientRect();\n      var newOffset = _anchorRect[anchor.type] - _scrollRect[anchor.type];\n      scrollRef.current.scrollTop += newOffset - anchor.offset;\n    }\n    setPosition(position);\n  }, deps);\n  (0, $6TXnl$reactariautils.useLayoutEffect)(updatePosition, deps);\n  $cd94b4896dd97759$var$useResize(updatePosition);\n  (0, $6TXnl$reactariautils.useResizeObserver)({\n    ref: overlayRef,\n    onResize: updatePosition\n  });\n  (0, $6TXnl$reactariautils.useResizeObserver)({\n    ref: targetRef,\n    onResize: updatePosition\n  });\n  var isResizing = (0, $6TXnl$react.useRef)(false);\n  (0, $6TXnl$reactariautils.useLayoutEffect)(function () {\n    var timeout;\n    var onResize = function onResize() {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(function () {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n    var onScroll = function onScroll() {\n      if (isResizing.current) onResize();\n    };\n    $cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.addEventListener('resize', onResize);\n    $cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.addEventListener('scroll', onScroll);\n    return function () {\n      $cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.removeEventListener('resize', onResize);\n      $cd94b4896dd97759$var$visualViewport === null || $cd94b4896dd97759$var$visualViewport === void 0 ? void 0 : $cd94b4896dd97759$var$visualViewport.removeEventListener('scroll', onScroll);\n    };\n  }, [updatePosition]);\n  var close = (0, $6TXnl$react.useCallback)(function () {\n    if (!isResizing.current) onClose === null || onClose === void 0 ? void 0 : onClose();\n  }, [onClose, isResizing]);\n  (0, $9a8aa1b0b336ea3a$exports.useCloseOnScroll)({\n    triggerRef: targetRef,\n    isOpen: isOpen,\n    onClose: onClose && close\n  });\n  var _position_maxHeight, _position_placement, _position_triggerAnchorPoint;\n  return {\n    overlayProps: {\n      style: Object.assign({\n        position: position ? 'absolute' : 'fixed',\n        top: !position ? 0 : undefined,\n        left: !position ? 0 : undefined,\n        zIndex: 100000\n      }, position === null || position === void 0 ? void 0 : position.position, {\n        maxHeight: (_position_maxHeight = position === null || position === void 0 ? void 0 : position.maxHeight) !== null && _position_maxHeight !== void 0 ? _position_maxHeight : '100vh'\n      })\n    },\n    placement: (_position_placement = position === null || position === void 0 ? void 0 : position.placement) !== null && _position_placement !== void 0 ? _position_placement : null,\n    triggerAnchorPoint: (_position_triggerAnchorPoint = position === null || position === void 0 ? void 0 : position.triggerAnchorPoint) !== null && _position_triggerAnchorPoint !== void 0 ? _position_triggerAnchorPoint : null,\n    arrowProps: {\n      'aria-hidden': 'true',\n      role: 'presentation',\n      style: {\n        left: position === null || position === void 0 ? void 0 : position.arrowOffsetLeft,\n        top: position === null || position === void 0 ? void 0 : position.arrowOffsetTop\n      }\n    },\n    updatePosition: updatePosition\n  };\n}\nfunction $cd94b4896dd97759$var$useResize(onResize) {\n  (0, $6TXnl$reactariautils.useLayoutEffect)(function () {\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\nfunction $cd94b4896dd97759$var$translateRTL(position, direction) {\n  if (direction === 'rtl') return position.replace('start', 'right').replace('end', 'left');\n  return position.replace('start', 'left').replace('end', 'right');\n}","map":{"version":3,"names":["$cd94b4896dd97759$var$visualViewport","document","window","visualViewport","$cd94b4896dd97759$export$d39e1813b3bdd0e1","props","_ref","$6TXnl$reactariai18n","useLocale","direction","arrowSize","targetRef","overlayRef","arrowRef","_props$scrollRef","scrollRef","_props$placement","placement","_props$containerPaddi","containerPadding","_props$shouldFlip","shouldFlip","_props$boundaryElemen","boundaryElement","body","_props$offset","offset","_props$crossOffset","crossOffset","_props$shouldUpdatePo","shouldUpdatePosition","_props$isOpen","isOpen","onClose","maxHeight","_props$arrowBoundaryO","arrowBoundaryOffset","_ref2","$6TXnl$react","useState","_ref3","_slicedToArray","position","setPosition","deps","current","lastScale","useRef","scale","useEffect","updatePosition","useCallback","anchor","contains","activeElement","_document_activeElement","anchorRect","getBoundingClientRect","scrollRect","_anchorRect_top","type","top","height","_anchorRect_bottom","bottom","overlay","_window_visualViewport","style","_window_visualViewport_height","innerHeight","$5935ba4d7da2c103$exports","calculatePosition","$cd94b4896dd97759$var$translateRTL","overlayNode","targetNode","scrollNode","padding","getRect","width","left","right","Object","keys","forEach","key","newOffset","scrollTop","$6TXnl$reactariautils","useLayoutEffect","$cd94b4896dd97759$var$useResize","useResizeObserver","ref","onResize","isResizing","timeout","clearTimeout","setTimeout","onScroll","addEventListener","removeEventListener","close","$9a8aa1b0b336ea3a$exports","useCloseOnScroll","triggerRef","_position_maxHeight","_position_placement","_position_triggerAnchorPoint","overlayProps","assign","undefined","zIndex","triggerAnchorPoint","arrowProps","role","arrowOffsetLeft","arrowOffsetTop","replace"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\useOverlayPosition.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {calculatePosition, getRect, PositionResult} from './calculatePosition';\nimport {DOMAttributes, RefObject} from '@react-types/shared';\nimport {Placement, PlacementAxis, PositionProps} from '@react-types/overlays';\nimport {useCallback, useEffect, useRef, useState} from 'react';\nimport {useCloseOnScroll} from './useCloseOnScroll';\nimport {useLayoutEffect, useResizeObserver} from '@react-aria/utils';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface AriaPositionProps extends PositionProps {\n  /**\n   * Cross size of the overlay arrow in pixels.\n   * @default 0\n   */\n  arrowSize?: number,\n  /**\n   * Element that that serves as the positioning boundary.\n   * @default document.body\n   */\n  boundaryElement?: Element,\n  /**\n   * The ref for the element which the overlay positions itself with respect to.\n   */\n  targetRef: RefObject<Element | null>,\n  /**\n   * The ref for the overlay element.\n   */\n  overlayRef: RefObject<Element | null>,\n  /**\n   * The ref for the arrow element.\n   */\n  arrowRef?: RefObject<Element | null>,\n  /**\n   * A ref for the scrollable region within the overlay.\n   * @default overlayRef\n   */\n  scrollRef?: RefObject<Element | null>,\n  /**\n   * Whether the overlay should update its position automatically.\n   * @default true\n   */\n  shouldUpdatePosition?: boolean,\n  /** Handler that is called when the overlay should close. */\n  onClose?: (() => void) | null,\n  /**\n   * The maxHeight specified for the overlay element.\n   * By default, it will take all space up to the current viewport height.\n   */\n  maxHeight?: number,\n  /**\n   * The minimum distance the arrow's edge should be from the edge of the overlay element.\n   * @default 0\n   */\n  arrowBoundaryOffset?: number\n}\n\nexport interface PositionAria {\n  /** Props for the overlay container element. */\n  overlayProps: DOMAttributes,\n  /** Props for the overlay tip arrow if any. */\n  arrowProps: DOMAttributes,\n  /** Placement of the overlay with respect to the overlay trigger. */\n  placement: PlacementAxis | null,\n  /** The origin of the target in the overlay's coordinate system. Useful for animations. */\n  triggerAnchorPoint: {x: number, y: number} | null,\n  /** Updates the position of the overlay. */\n  updatePosition(): void\n}\n\ninterface ScrollAnchor {\n  type: 'top' | 'bottom',\n  offset: number\n}\n\nlet visualViewport = typeof document !== 'undefined' ? window.visualViewport : null;\n\n/**\n * Handles positioning overlays like popovers and menus relative to a trigger\n * element, and updating the position when the window resizes.\n */\nexport function useOverlayPosition(props: AriaPositionProps): PositionAria {\n  let {direction} = useLocale();\n  let {\n    arrowSize,\n    targetRef,\n    overlayRef,\n    arrowRef,\n    scrollRef = overlayRef,\n    placement = 'bottom' as Placement,\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    onClose,\n    maxHeight,\n    arrowBoundaryOffset = 0\n  } = props;\n  let [position, setPosition] = useState<PositionResult | null>(null);\n\n  let deps = [\n    shouldUpdatePosition,\n    placement,\n    overlayRef.current,\n    targetRef.current,\n    arrowRef?.current,\n    scrollRef.current,\n    containerPadding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    isOpen,\n    direction,\n    maxHeight,\n    arrowBoundaryOffset,\n    arrowSize\n  ];\n\n  // Note, the position freezing breaks if body sizes itself dynamicly with the visual viewport but that might\n  // just be a non-realistic use case\n  // Upon opening a overlay, record the current visual viewport scale so we can freeze the overlay styles\n  let lastScale = useRef(visualViewport?.scale);\n  useEffect(() => {\n    if (isOpen) {\n      lastScale.current = visualViewport?.scale;\n    }\n  }, [isOpen]);\n\n  let updatePosition = useCallback(() => {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !boundaryElement) {\n      return;\n    }\n\n    if (visualViewport?.scale !== lastScale.current) {\n      return;\n    }\n\n    // Determine a scroll anchor based on the focused element.\n    // This stores the offset of the anchor element from the scroll container\n    // so it can be restored after repositioning. This way if the overlay height\n    // changes, the focused element appears to stay in the same position.\n    let anchor: ScrollAnchor | null = null;\n    if (scrollRef.current && scrollRef.current.contains(document.activeElement)) {\n      let anchorRect = document.activeElement?.getBoundingClientRect();\n      let scrollRect = scrollRef.current.getBoundingClientRect();\n      // Anchor from the top if the offset is in the top half of the scrollable element,\n      // otherwise anchor from the bottom.\n      anchor = {\n        type: 'top',\n        offset: (anchorRect?.top ?? 0) - scrollRect.top\n      };\n      if (anchor.offset > scrollRect.height / 2) {\n        anchor.type = 'bottom';\n        anchor.offset = (anchorRect?.bottom ?? 0) - scrollRect.bottom;\n      }\n    }\n\n    // Always reset the overlay's previous max height if not defined by the user so that we can compensate for\n    // RAC collections populating after a second render and properly set a correct max height + positioning when it populates.\n    let overlay = (overlayRef.current as HTMLElement);\n    if (!maxHeight && overlayRef.current) {\n      overlay.style.top = '0px';\n      overlay.style.bottom = '';\n      overlay.style.maxHeight = (window.visualViewport?.height ?? window.innerHeight) + 'px';\n    }\n\n    let position = calculatePosition({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current || overlayRef.current,\n      padding: containerPadding,\n      shouldFlip,\n      boundaryElement,\n      offset,\n      crossOffset,\n      maxHeight,\n      arrowSize: arrowSize ?? (arrowRef?.current ? getRect(arrowRef.current, true).width : 0),\n      arrowBoundaryOffset\n    });\n\n    if (!position.position) {\n      return;\n    }\n\n    // Modify overlay styles directly so positioning happens immediately without the need of a second render\n    // This is so we don't have to delay autoFocus scrolling or delay applying preventScroll for popovers\n    overlay.style.top = '';\n    overlay.style.bottom = '';\n    overlay.style.left = '';\n    overlay.style.right = '';\n\n    Object.keys(position.position).forEach(key => overlay.style[key] = (position.position!)[key] + 'px');\n    overlay.style.maxHeight = position.maxHeight != null ?  position.maxHeight + 'px' : '';\n\n    // Restore scroll position relative to anchor element.\n    if (anchor && document.activeElement && scrollRef.current) {\n      let anchorRect = document.activeElement.getBoundingClientRect();\n      let scrollRect = scrollRef.current.getBoundingClientRect();\n      let newOffset = anchorRect[anchor.type] - scrollRect[anchor.type];\n      scrollRef.current.scrollTop += newOffset - anchor.offset;\n    }\n\n    // Trigger a set state for a second render anyway for arrow positioning\n    setPosition(position);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  // Update position when anything changes\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useLayoutEffect(updatePosition, deps);\n\n  // Update position on window resize\n  useResize(updatePosition);\n\n  // Update position when the overlay changes size (might need to flip).\n  useResizeObserver({\n    ref: overlayRef,\n    onResize: updatePosition\n  });\n\n  // Update position when the target changes size (might need to flip).\n  useResizeObserver({\n    ref: targetRef,\n    onResize: updatePosition\n  });\n\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout: ReturnType<typeof setTimeout>;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n\n      updatePosition();\n    };\n\n    // Only reposition the overlay if a scroll event happens immediately as a result of resize (aka the virtual keyboard has appears)\n    // We don't want to reposition the overlay if the user has pinch zoomed in and is scrolling the viewport around.\n    let onScroll = () => {\n      if (isResizing.current) {\n        onResize();\n      }\n    };\n\n    visualViewport?.addEventListener('resize', onResize);\n    visualViewport?.addEventListener('scroll', onScroll);\n    return () => {\n      visualViewport?.removeEventListener('resize', onResize);\n      visualViewport?.removeEventListener('scroll', onScroll);\n    };\n  }, [updatePosition]);\n\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose?.();\n    }\n  }, [onClose, isResizing]);\n\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose && close\n  });\n\n  return {\n    overlayProps: {\n      style: {\n        position: position ? 'absolute' : 'fixed',\n        top: !position ? 0 : undefined,\n        left: !position ? 0 : undefined,\n        zIndex: 100000, // should match the z-index in ModalTrigger\n        ...position?.position,\n        maxHeight: position?.maxHeight ?? '100vh'\n      }\n    },\n    placement: position?.placement ?? null,\n    triggerAnchorPoint: position?.triggerAnchorPoint ?? null,\n    arrowProps: {\n      'aria-hidden': 'true',\n      role: 'presentation',\n      style: {\n        left: position?.arrowOffsetLeft,\n        top: position?.arrowOffsetTop\n      }\n    },\n    updatePosition\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}