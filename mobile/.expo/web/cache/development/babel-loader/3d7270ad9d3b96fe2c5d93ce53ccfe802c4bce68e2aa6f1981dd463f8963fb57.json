{"ast":null,"code":"var _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _excluded = [\"register\"],\n  _excluded2 = [\"onPress\", \"onPressChange\", \"onPressStart\", \"onPressEnd\", \"onPressUp\", \"onClick\", \"isDisabled\", \"isPressed\", \"preventFocusOnPress\", \"shouldCancelOnPointerExit\", \"allowTextSelectionOnPress\", \"ref\"];\nvar $625cf83917e112ad$exports = require(\"./utils.main.js\");\nvar $f7e14e656343df57$exports = require(\"./textSelection.main.js\");\nvar $01d3f539e91688c8$exports = require(\"./context.main.js\");\nvar $bBqCQ$swchelperscjs_class_private_field_getcjs = require(\"@swc/helpers/cjs/_class_private_field_get.cjs\");\nvar $bBqCQ$swchelperscjs_class_private_field_initcjs = require(\"@swc/helpers/cjs/_class_private_field_init.cjs\");\nvar $bBqCQ$swchelperscjs_class_private_field_setcjs = require(\"@swc/helpers/cjs/_class_private_field_set.cjs\");\nvar $bBqCQ$reactariautils = require(\"@react-aria/utils\");\nvar $bBqCQ$reactdom = require(\"react-dom\");\nvar $bBqCQ$react = require(\"react\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"usePress\", function () {\n  return $0294ea432cd92340$export$45712eceda6fad21;\n});\nfunction $0294ea432cd92340$var$usePressResponderContext(props) {\n  var context = (0, $bBqCQ$react.useContext)((0, $01d3f539e91688c8$exports.PressResponderContext));\n  if (context) {\n    var register = context.register,\n      contextProps = _objectWithoutProperties(context, _excluded);\n    props = (0, $bBqCQ$reactariautils.mergeProps)(contextProps, props);\n    register();\n  }\n  (0, $bBqCQ$reactariautils.useSyncRef)(context, props.ref);\n  return props;\n}\nvar $0294ea432cd92340$var$_shouldStopPropagation = new WeakMap();\nvar $0294ea432cd92340$var$PressEvent = function () {\n  \"use strict\";\n\n  function $0294ea432cd92340$var$PressEvent(type, pointerType, originalEvent, state) {\n    _classCallCheck(this, $0294ea432cd92340$var$PressEvent);\n    (0, $bBqCQ$swchelperscjs_class_private_field_initcjs._)(this, $0294ea432cd92340$var$_shouldStopPropagation, {\n      writable: true,\n      value: void 0\n    });\n    (0, $bBqCQ$swchelperscjs_class_private_field_setcjs._)(this, $0294ea432cd92340$var$_shouldStopPropagation, true);\n    var _state_target;\n    var currentTarget = (_state_target = state === null || state === void 0 ? void 0 : state.target) !== null && _state_target !== void 0 ? _state_target : originalEvent.currentTarget;\n    var rect = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.getBoundingClientRect();\n    var x,\n      y = 0;\n    var clientX,\n      clientY = null;\n    if (originalEvent.clientX != null && originalEvent.clientY != null) {\n      clientX = originalEvent.clientX;\n      clientY = originalEvent.clientY;\n    }\n    if (rect) {\n      if (clientX != null && clientY != null) {\n        x = clientX - rect.left;\n        y = clientY - rect.top;\n      } else {\n        x = rect.width / 2;\n        y = rect.height / 2;\n      }\n    }\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n    this.x = x;\n    this.y = y;\n  }\n  return _createClass($0294ea432cd92340$var$PressEvent, [{\n    key: \"continuePropagation\",\n    value: function continuePropagation() {\n      (0, $bBqCQ$swchelperscjs_class_private_field_setcjs._)(this, $0294ea432cd92340$var$_shouldStopPropagation, false);\n    }\n  }, {\n    key: \"shouldStopPropagation\",\n    get: function get() {\n      return (0, $bBqCQ$swchelperscjs_class_private_field_getcjs._)(this, $0294ea432cd92340$var$_shouldStopPropagation);\n    }\n  }]);\n}();\nvar $0294ea432cd92340$var$LINK_CLICKED = Symbol('linkClicked');\nvar $0294ea432cd92340$var$STYLE_ID = 'react-aria-pressable-style';\nvar $0294ea432cd92340$var$PRESSABLE_ATTRIBUTE = 'data-react-aria-pressable';\nfunction $0294ea432cd92340$export$45712eceda6fad21(props) {\n  var _$0294ea432cd92340$va = $0294ea432cd92340$var$usePressResponderContext(props),\n    onPress = _$0294ea432cd92340$va.onPress,\n    onPressChange = _$0294ea432cd92340$va.onPressChange,\n    onPressStart = _$0294ea432cd92340$va.onPressStart,\n    onPressEnd = _$0294ea432cd92340$va.onPressEnd,\n    onPressUp = _$0294ea432cd92340$va.onPressUp,\n    onClick = _$0294ea432cd92340$va.onClick,\n    isDisabled = _$0294ea432cd92340$va.isDisabled,\n    isPressedProp = _$0294ea432cd92340$va.isPressed,\n    preventFocusOnPress = _$0294ea432cd92340$va.preventFocusOnPress,\n    shouldCancelOnPointerExit = _$0294ea432cd92340$va.shouldCancelOnPointerExit,\n    allowTextSelectionOnPress = _$0294ea432cd92340$va.allowTextSelectionOnPress,\n    domRef = _$0294ea432cd92340$va.ref,\n    domProps = _objectWithoutProperties(_$0294ea432cd92340$va, _excluded2);\n  var _ref = (0, $bBqCQ$react.useState)(false),\n    _ref2 = _slicedToArray(_ref, 2),\n    isPressed = _ref2[0],\n    setPressed = _ref2[1];\n  var ref = (0, $bBqCQ$react.useRef)({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null,\n    disposables: []\n  });\n  var _ref3 = (0, $bBqCQ$reactariautils.useGlobalListeners)(),\n    addGlobalListener = _ref3.addGlobalListener,\n    removeAllGlobalListeners = _ref3.removeAllGlobalListeners;\n  var triggerPressStart = (0, $bBqCQ$reactariautils.useEffectEvent)(function (originalEvent, pointerType) {\n    var state = ref.current;\n    if (isDisabled || state.didFirePressStart) return false;\n    var shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      var event = new $0294ea432cd92340$var$PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) onPressChange(true);\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n  var triggerPressEnd = (0, $bBqCQ$reactariautils.useEffectEvent)(function (originalEvent, pointerType) {\n    var wasPressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var state = ref.current;\n    if (!state.didFirePressStart) return false;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n    var shouldStopPropagation = true;\n    if (onPressEnd) {\n      var event = new $0294ea432cd92340$var$PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) onPressChange(false);\n    setPressed(false);\n    if (onPress && wasPressed && !isDisabled) {\n      var _event = new $0294ea432cd92340$var$PressEvent('press', pointerType, originalEvent);\n      onPress(_event);\n      shouldStopPropagation && (shouldStopPropagation = _event.shouldStopPropagation);\n    }\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n  var triggerPressUp = (0, $bBqCQ$reactariautils.useEffectEvent)(function (originalEvent, pointerType) {\n    var state = ref.current;\n    if (isDisabled) return false;\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      var event = new $0294ea432cd92340$var$PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n    return true;\n  });\n  var cancel = (0, $bBqCQ$reactariautils.useEffectEvent)(function (e) {\n    var state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.didFirePressStart && state.pointerType != null) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$exports.restoreTextSelection)(state.target);\n      for (var dispose of state.disposables) dispose();\n      state.disposables = [];\n    }\n  });\n  var cancelOnPointerExit = (0, $bBqCQ$reactariautils.useEffectEvent)(function (e) {\n    if (shouldCancelOnPointerExit) cancel(e);\n  });\n  var triggerClick = (0, $bBqCQ$reactariautils.useEffectEvent)(function (e) {\n    if (isDisabled) return;\n    onClick === null || onClick === void 0 ? void 0 : onClick(e);\n  });\n  var triggerSyntheticClick = (0, $bBqCQ$reactariautils.useEffectEvent)(function (e, target) {\n    if (isDisabled) return;\n    if (onClick) {\n      var event = new MouseEvent('click', e);\n      (0, $625cf83917e112ad$exports.setEventTarget)(event, target);\n      onClick((0, $625cf83917e112ad$exports.createSyntheticEvent)(event));\n    }\n  });\n  var pressProps = (0, $bBqCQ$react.useMemo)(function () {\n    var state = ref.current;\n    var pressProps = {\n      onKeyDown: function onKeyDown(e) {\n        if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && (0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) {\n          var _state_metaKeyEvents;\n          if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard((0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent), e.key)) e.preventDefault();\n          var shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            state.pointerType = 'keyboard';\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n            var originalTarget = e.currentTarget;\n            var pressUp = function pressUp(e) {\n              if ($0294ea432cd92340$var$isValidKeyboardEvent(e, originalTarget) && !e.repeat && (0, $bBqCQ$reactariautils.nodeContains)(originalTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e)) && state.target) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), 'keyboard');\n            };\n            addGlobalListener((0, $bBqCQ$reactariautils.getOwnerDocument)(e.currentTarget), 'keyup', (0, $bBqCQ$reactariautils.chain)(pressUp, onKeyUp), true);\n          }\n          if (shouldStopPropagation) e.stopPropagation();\n          if (e.metaKey && (0, $bBqCQ$reactariautils.isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);\n        } else if (e.key === 'Meta') state.metaKeyEvents = new Map();\n      },\n      onClick: function onClick(e) {\n        if (e && !(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(0, $bBqCQ$reactariautils.openLink).isOpening) {\n          var shouldStopPropagation = true;\n          if (isDisabled) e.preventDefault();\n          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || (0, $bBqCQ$reactariautils.isVirtualClick)(e.nativeEvent))) {\n            var stopPressStart = triggerPressStart(e, 'virtual');\n            var stopPressUp = triggerPressUp(e, 'virtual');\n            var stopPressEnd = triggerPressEnd(e, 'virtual');\n            triggerClick(e);\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          } else if (state.isPressed && state.pointerType !== 'keyboard') {\n            var pointerType = state.pointerType || e.nativeEvent.pointerType || 'virtual';\n            var _stopPressUp = triggerPressUp($0294ea432cd92340$var$createEvent(e.currentTarget, e), pointerType);\n            var _stopPressEnd = triggerPressEnd($0294ea432cd92340$var$createEvent(e.currentTarget, e), pointerType, true);\n            shouldStopPropagation = _stopPressUp && _stopPressEnd;\n            state.isOverTarget = false;\n            triggerClick(e);\n            cancel(e);\n          }\n          state.ignoreEmulatedMouseEvents = false;\n          if (shouldStopPropagation) e.stopPropagation();\n        }\n      }\n    };\n    var onKeyUp = function onKeyUp(e) {\n      var _state_metaKeyEvents;\n      if (state.isPressed && state.target && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {\n        var _state_metaKeyEvents1;\n        if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard((0, $bBqCQ$reactariautils.getEventTarget)(e), e.key)) e.preventDefault();\n        var target = (0, $bBqCQ$reactariautils.getEventTarget)(e);\n        var wasPressed = (0, $bBqCQ$reactariautils.nodeContains)(state.target, (0, $bBqCQ$reactariautils.getEventTarget)(e));\n        triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), 'keyboard', wasPressed);\n        if (wasPressed) triggerSyntheticClick(e, state.target);\n        removeAllGlobalListeners();\n        if (e.key !== 'Enter' && $0294ea432cd92340$var$isHTMLAnchorLink(state.target) && (0, $bBqCQ$reactariautils.nodeContains)(state.target, target) && !e[$0294ea432cd92340$var$LINK_CLICKED]) {\n          e[$0294ea432cd92340$var$LINK_CLICKED] = true;\n          (0, $bBqCQ$reactariautils.openLink)(state.target, e, false);\n        }\n        state.isPressed = false;\n        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n      } else if (e.key === 'Meta' && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n        var _state_target;\n        var events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (var event of events.values()) (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent('keyup', event));\n      }\n    };\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = function (e) {\n        if (e.button !== 0 || !(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        if ((0, $bBqCQ$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n        state.pointerType = e.pointerType;\n        var shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n          if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$exports.disableTextSelection)(state.target);\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          var target = (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent);\n          if ('releasePointerCapture' in target) target.releasePointerCapture(e.pointerId);\n          addGlobalListener((0, $bBqCQ$reactariautils.getOwnerDocument)(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener((0, $bBqCQ$reactariautils.getOwnerDocument)(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseDown = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        if (e.button === 0) {\n          if (preventFocusOnPress) {\n            var dispose = (0, $625cf83917e112ad$exports.preventFocus)(e.target);\n            if (dispose) state.disposables.push(dispose);\n          }\n          e.stopPropagation();\n        }\n      };\n      pressProps.onPointerUp = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent)) || state.pointerType === 'virtual') return;\n        if (e.button === 0 && !state.isPressed) triggerPressUp(e, state.pointerType || e.pointerType);\n      };\n      pressProps.onPointerEnter = function (e) {\n        if (e.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = true;\n          triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);\n        }\n      };\n      pressProps.onPointerLeave = function (e) {\n        if (e.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n      var onPointerUp = function onPointerUp(e) {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if ((0, $bBqCQ$reactariautils.nodeContains)(state.target, (0, $bBqCQ$reactariautils.getEventTarget)(e)) && state.pointerType != null) {\n            var clicked = false;\n            var timeout = setTimeout(function () {\n              if (state.isPressed && state.target instanceof HTMLElement) {\n                if (clicked) cancel(e);else {\n                  (0, $bBqCQ$reactariautils.focusWithoutScrolling)(state.target);\n                  state.target.click();\n                }\n              }\n            }, 80);\n            addGlobalListener(e.currentTarget, 'click', function () {\n              return clicked = true;\n            }, true);\n            state.disposables.push(function () {\n              return clearTimeout(timeout);\n            });\n          } else cancel(e);\n          state.isOverTarget = false;\n        }\n      };\n      var onPointerCancel = function onPointerCancel(e) {\n        cancel(e);\n      };\n      pressProps.onDragStart = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        cancel(e);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      pressProps.onMouseDown = function (e) {\n        if (e.button !== 0 || !(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = (0, $bBqCQ$reactariautils.isVirtualClick)(e.nativeEvent) ? 'virtual' : 'mouse';\n        var shouldStopPropagation = (0, $bBqCQ$reactdom.flushSync)(function () {\n          return triggerPressStart(e, state.pointerType);\n        });\n        if (shouldStopPropagation) e.stopPropagation();\n        if (preventFocusOnPress) {\n          var dispose = (0, $625cf83917e112ad$exports.preventFocus)(e.target);\n          if (dispose) state.disposables.push(dispose);\n        }\n        addGlobalListener((0, $bBqCQ$reactariautils.getOwnerDocument)(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n      pressProps.onMouseEnter = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        var shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseLeave = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        var shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseUp = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0 && !state.isPressed) triggerPressUp(e, state.pointerType || 'mouse');\n      };\n      var onMouseUp = function onMouseUp(e) {\n        if (e.button !== 0) return;\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n        if (state.target && state.target.contains(e.target) && state.pointerType != null) ;else cancel(e);\n        state.isOverTarget = false;\n      };\n      pressProps.onTouchStart = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        var touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);\n        if (!touch) return;\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n        if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$exports.disableTextSelection)(state.target);\n        var shouldStopPropagation = triggerPressStart($0294ea432cd92340$var$createTouchEvent(state.target, e), state.pointerType);\n        if (shouldStopPropagation) e.stopPropagation();\n        addGlobalListener((0, $bBqCQ$reactariautils.getOwnerWindow)(e.currentTarget), 'scroll', onScroll, true);\n      };\n      pressProps.onTouchMove = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        var touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);\n        var shouldStopPropagation = true;\n        if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart($0294ea432cd92340$var$createTouchEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd($0294ea432cd92340$var$createTouchEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit($0294ea432cd92340$var$createTouchEvent(state.target, e));\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onTouchEnd = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        var touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);\n        var shouldStopPropagation = true;\n        if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp($0294ea432cd92340$var$createTouchEvent(state.target, e), state.pointerType);\n          shouldStopPropagation = triggerPressEnd($0294ea432cd92340$var$createTouchEvent(state.target, e), state.pointerType);\n          triggerSyntheticClick(e.nativeEvent, state.target);\n        } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd($0294ea432cd92340$var$createTouchEvent(state.target, e), state.pointerType, false);\n        if (shouldStopPropagation) e.stopPropagation();\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) (0, $f7e14e656343df57$exports.restoreTextSelection)(state.target);\n        removeAllGlobalListeners();\n      };\n      pressProps.onTouchCancel = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        e.stopPropagation();\n        if (state.isPressed) cancel($0294ea432cd92340$var$createTouchEvent(state.target, e));\n      };\n      var onScroll = function onScroll(e) {\n        if (state.isPressed && (0, $bBqCQ$reactariautils.nodeContains)((0, $bBqCQ$reactariautils.getEventTarget)(e), state.target)) cancel({\n          currentTarget: state.target,\n          shiftKey: false,\n          ctrlKey: false,\n          metaKey: false,\n          altKey: false\n        });\n      };\n      pressProps.onDragStart = function (e) {\n        if (!(0, $bBqCQ$reactariautils.nodeContains)(e.currentTarget, (0, $bBqCQ$reactariautils.getEventTarget)(e.nativeEvent))) return;\n        cancel(e);\n      };\n    }\n    return pressProps;\n  }, [addGlobalListener, isDisabled, preventFocusOnPress, removeAllGlobalListeners, allowTextSelectionOnPress, cancel, cancelOnPointerExit, triggerPressEnd, triggerPressStart, triggerPressUp, triggerClick, triggerSyntheticClick]);\n  (0, $bBqCQ$react.useEffect)(function () {\n    if (!domRef || process.env.NODE_ENV === 'test') return;\n    var ownerDocument = (0, $bBqCQ$reactariautils.getOwnerDocument)(domRef.current);\n    if (!ownerDocument || !ownerDocument.head || ownerDocument.getElementById($0294ea432cd92340$var$STYLE_ID)) return;\n    var style = ownerDocument.createElement('style');\n    style.id = $0294ea432cd92340$var$STYLE_ID;\n    style.textContent = `\n@layer {\n  [${$0294ea432cd92340$var$PRESSABLE_ATTRIBUTE}] {\n    touch-action: pan-x pan-y pinch-zoom;\n  }\n}\n    `.trim();\n    ownerDocument.head.prepend(style);\n  }, [domRef]);\n  (0, $bBqCQ$react.useEffect)(function () {\n    var state = ref.current;\n    return function () {\n      var _state_target;\n      if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$exports.restoreTextSelection)((_state_target = state.target) !== null && _state_target !== void 0 ? _state_target : undefined);\n      for (var dispose of state.disposables) dispose();\n      state.disposables = [];\n    };\n  }, [allowTextSelectionOnPress]);\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: (0, $bBqCQ$reactariautils.mergeProps)(domProps, pressProps, _defineProperty({}, $0294ea432cd92340$var$PRESSABLE_ATTRIBUTE, true))\n  };\n}\nfunction $0294ea432cd92340$var$isHTMLAnchorLink(target) {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\nfunction $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {\n  var key = event.key,\n    code = event.code;\n  var element = currentTarget;\n  var role = element.getAttribute('role');\n  return (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') && !(element instanceof (0, $bBqCQ$reactariautils.getOwnerWindow)(element).HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof (0, $bBqCQ$reactariautils.getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) && !((role === 'link' || !role && $0294ea432cd92340$var$isHTMLAnchorLink(element)) && key !== 'Enter');\n}\nfunction $0294ea432cd92340$var$getTouchFromEvent(event) {\n  var targetTouches = event.targetTouches;\n  if (targetTouches.length > 0) return targetTouches[0];\n  return null;\n}\nfunction $0294ea432cd92340$var$getTouchById(event, pointerId) {\n  var changedTouches = event.changedTouches;\n  for (var i = 0; i < changedTouches.length; i++) {\n    var touch = changedTouches[i];\n    if (touch.identifier === pointerId) return touch;\n  }\n  return null;\n}\nfunction $0294ea432cd92340$var$createTouchEvent(target, e) {\n  var clientX = 0;\n  var clientY = 0;\n  if (e.targetTouches && e.targetTouches.length === 1) {\n    clientX = e.targetTouches[0].clientX;\n    clientY = e.targetTouches[0].clientY;\n  }\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX: clientX,\n    clientY: clientY\n  };\n}\nfunction $0294ea432cd92340$var$createEvent(target, e) {\n  var clientX = e.clientX;\n  var clientY = e.clientY;\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX: clientX,\n    clientY: clientY\n  };\n}\nfunction $0294ea432cd92340$var$getPointClientRect(point) {\n  var offsetX = 0;\n  var offsetY = 0;\n  if (point.width !== undefined) offsetX = point.width / 2;else if (point.radiusX !== undefined) offsetX = point.radiusX;\n  if (point.height !== undefined) offsetY = point.height / 2;else if (point.radiusY !== undefined) offsetY = point.radiusY;\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\nfunction $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {\n  if (a.left > b.right || b.left > a.right) return false;\n  if (a.top > b.bottom || b.top > a.bottom) return false;\n  return true;\n}\nfunction $0294ea432cd92340$var$isOverTarget(point, target) {\n  var rect = target.getBoundingClientRect();\n  var pointRect = $0294ea432cd92340$var$getPointClientRect(point);\n  return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $0294ea432cd92340$var$shouldPreventDefaultUp(target) {\n  if (target instanceof HTMLInputElement) return false;\n  if (target instanceof HTMLButtonElement) return target.type !== 'submit' && target.type !== 'reset';\n  if ($0294ea432cd92340$var$isHTMLAnchorLink(target)) return false;\n  return true;\n}\nfunction $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {\n  if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);\n  return $0294ea432cd92340$var$shouldPreventDefaultUp(target);\n}\nvar $0294ea432cd92340$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\nfunction $0294ea432cd92340$var$isValidInputKey(target, key) {\n  return target.type === 'checkbox' || target.type === 'radio' ? key === ' ' : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);\n}","map":{"version":3,"names":["$0294ea432cd92340$var$usePressResponderContext","props","context","$bBqCQ$react","useContext","$01d3f539e91688c8$exports","PressResponderContext","register","contextProps","_objectWithoutProperties","_excluded","$bBqCQ$reactariautils","mergeProps","useSyncRef","ref","$0294ea432cd92340$var$_shouldStopPropagation","WeakMap","$0294ea432cd92340$var$PressEvent","type","pointerType","originalEvent","state","_classCallCheck","$bBqCQ$swchelperscjs_class_private_field_initcjs","_","_state_target","currentTarget","target","rect","getBoundingClientRect","x","y","clientX","clientY","left","top","width","height","shiftKey","metaKey","ctrlKey","altKey","_createClass","key","value","continuePropagation","get","$bBqCQ$swchelperscjs_class_private_field_getcjs","$0294ea432cd92340$var$LINK_CLICKED","Symbol","$0294ea432cd92340$var$STYLE_ID","$0294ea432cd92340$var$PRESSABLE_ATTRIBUTE","$0294ea432cd92340$export$45712eceda6fad21","_$0294ea432cd92340$va","onPress","onPressChange","onPressStart","onPressEnd","onPressUp","onClick","isDisabled","isPressedProp","isPressed","preventFocusOnPress","shouldCancelOnPointerExit","allowTextSelectionOnPress","domRef","domProps","_excluded2","_ref","useState","_ref2","_slicedToArray","setPressed","useRef","ignoreEmulatedMouseEvents","didFirePressStart","isTriggeringEvent","activePointerId","isOverTarget","disposables","_ref3","useGlobalListeners","addGlobalListener","removeAllGlobalListeners","triggerPressStart","useEffectEvent","current","shouldStopPropagation","event","triggerPressEnd","wasPressed","arguments","length","undefined","triggerPressUp","cancel","e","$0294ea432cd92340$var$createEvent","$f7e14e656343df57$exports","restoreTextSelection","dispose","cancelOnPointerExit","triggerClick","triggerSyntheticClick","MouseEvent","$625cf83917e112ad$exports","setEventTarget","createSyntheticEvent","pressProps","useMemo","onKeyDown","$0294ea432cd92340$var$isValidKeyboardEvent","nativeEvent","nodeContains","getEventTarget","_state_metaKeyEvents","$0294ea432cd92340$var$shouldPreventDefaultKeyboard","preventDefault","repeat","originalTarget","pressUp","getOwnerDocument","chain","onKeyUp","stopPropagation","isMac","metaKeyEvents","set","Map","button","openLink","isOpening","isVirtualClick","stopPressStart","stopPressUp","stopPressEnd","_state_metaKeyEvents1","$0294ea432cd92340$var$isHTMLAnchorLink","delete","size","events","values","dispatchEvent","KeyboardEvent","PointerEvent","onPointerDown","isVirtualPointerEvent","pointerId","disableTextSelection","releasePointerCapture","onPointerUp","onPointerCancel","onMouseDown","preventFocus","push","onPointerEnter","onPointerLeave","clicked","timeout","setTimeout","HTMLElement","focusWithoutScrolling","click","clearTimeout","onDragStart","process","env","NODE_ENV","$bBqCQ$reactdom","flushSync","onMouseUp","onMouseEnter","onMouseLeave","contains","onTouchStart","touch","$0294ea432cd92340$var$getTouchFromEvent","identifier","$0294ea432cd92340$var$createTouchEvent","getOwnerWindow","onScroll","onTouchMove","$0294ea432cd92340$var$getTouchById","$0294ea432cd92340$var$isOverTarget","onTouchEnd","onTouchCancel","useEffect","ownerDocument","head","getElementById","style","createElement","id","textContent","trim","prepend","_defineProperty","tagName","hasAttribute","code","element","role","getAttribute","HTMLInputElement","$0294ea432cd92340$var$isValidInputKey","HTMLTextAreaElement","isContentEditable","targetTouches","changedTouches","i","$0294ea432cd92340$var$getPointClientRect","point","offsetX","offsetY","radiusX","radiusY","right","bottom","$0294ea432cd92340$var$areRectanglesOverlapping","a","b","pointRect","$0294ea432cd92340$var$shouldPreventDefaultUp","HTMLButtonElement","$0294ea432cd92340$var$nonTextInputTypes","Set","has"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\interactions\\dist\\packages\\@react-aria\\interactions\\src\\usePress.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {\n  chain,\n  focusWithoutScrolling,\n  getEventTarget,\n  getOwnerDocument,\n  getOwnerWindow,\n  isMac,\n  isVirtualClick,\n  isVirtualPointerEvent,\n  mergeProps,\n  nodeContains,\n  openLink,\n  useEffectEvent,\n  useGlobalListeners,\n  useSyncRef\n} from '@react-aria/utils';\nimport {createSyntheticEvent, preventFocus, setEventTarget} from './utils';\nimport {disableTextSelection, restoreTextSelection} from './textSelection';\nimport {DOMAttributes, FocusableElement, PressEvent as IPressEvent, PointerType, PressEvents, RefObject} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {PressResponderContext} from './context';\nimport {MouseEvent as RMouseEvent, TouchEvent as RTouchEvent, useContext, useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface PressProps extends PressEvents {\n  /** Whether the target is in a controlled press state (e.g. an overlay it triggers is open). */\n  isPressed?: boolean,\n  /** Whether the press events should be disabled. */\n  isDisabled?: boolean,\n  /** Whether the target should not receive focus on press. */\n  preventFocusOnPress?: boolean,\n  /**\n   * Whether press events should be canceled when the pointer leaves the target while pressed.\n   * By default, this is `false`, which means if the pointer returns back over the target while\n   * still pressed, onPressStart will be fired again. If set to `true`, the press is canceled\n   * when the pointer leaves the target and onPressStart will not be fired if the pointer returns.\n   */\n  shouldCancelOnPointerExit?: boolean,\n  /** Whether text selection should be enabled on the pressable element. */\n  allowTextSelectionOnPress?: boolean\n}\n\nexport interface PressHookProps extends PressProps {\n  /** A ref to the target element. */\n  ref?: RefObject<Element | null>\n}\n\ninterface PressState {\n  isPressed: boolean,\n  ignoreEmulatedMouseEvents: boolean,\n  didFirePressStart: boolean,\n  isTriggeringEvent: boolean,\n  activePointerId: any,\n  target: FocusableElement | null,\n  isOverTarget: boolean,\n  pointerType: PointerType | null,\n  userSelect?: string,\n  metaKeyEvents?: Map<string, KeyboardEvent>,\n  disposables: Array<() => void>\n}\n\ninterface EventBase {\n  currentTarget: EventTarget | null,\n  shiftKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n  altKey: boolean,\n  clientX?: number,\n  clientY?: number,\n  targetTouches?: Array<{clientX?: number, clientY?: number}>\n}\n\nexport interface PressResult {\n  /** Whether the target is currently pressed. */\n  isPressed: boolean,\n  /** Props to spread on the target element. */\n  pressProps: DOMAttributes\n}\n\nfunction usePressResponderContext(props: PressHookProps): PressHookProps {\n  // Consume context from <PressResponder> and merge with props.\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let {register, ...contextProps} = context;\n    props = mergeProps(contextProps, props) as PressHookProps;\n    register();\n  }\n  useSyncRef(context, props.ref);\n\n  return props;\n}\n\nclass PressEvent implements IPressEvent {\n  type: IPressEvent['type'];\n  pointerType: PointerType;\n  target: Element;\n  shiftKey: boolean;\n  ctrlKey: boolean;\n  metaKey: boolean;\n  altKey: boolean;\n  x: number;\n  y: number;\n  #shouldStopPropagation = true;\n\n  constructor(type: IPressEvent['type'], pointerType: PointerType, originalEvent: EventBase, state?: PressState) {\n    let currentTarget = state?.target ?? originalEvent.currentTarget;\n    const rect: DOMRect | undefined = (currentTarget as Element)?.getBoundingClientRect();\n    let x, y = 0;\n    let clientX, clientY: number | null = null;\n    if (originalEvent.clientX != null && originalEvent.clientY != null) {\n      clientX = originalEvent.clientX;\n      clientY = originalEvent.clientY;\n    }\n    if (rect) {\n      if (clientX != null && clientY != null) {\n        x = clientX - rect.left;\n        y = clientY - rect.top;\n      } else {\n        x = rect.width / 2;\n        y = rect.height / 2;\n      }\n    }\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget as Element;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n    this.x = x;\n    this.y = y;\n  }\n\n  continuePropagation() {\n    this.#shouldStopPropagation = false;\n  }\n\n  get shouldStopPropagation() {\n    return this.#shouldStopPropagation;\n  }\n}\n\nconst LINK_CLICKED = Symbol('linkClicked');\nconst STYLE_ID = 'react-aria-pressable-style';\nconst PRESSABLE_ATTRIBUTE = 'data-react-aria-pressable';\n\n/**\n * Handles press interactions across mouse, touch, keyboard, and screen readers.\n * It normalizes behavior across browsers and platforms, and handles many nuances\n * of dealing with pointer and keyboard events.\n */\nexport function usePress(props: PressHookProps): PressResult {\n  let {\n    onPress,\n    onPressChange,\n    onPressStart,\n    onPressEnd,\n    onPressUp,\n    onClick,\n    isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress,\n    shouldCancelOnPointerExit,\n    allowTextSelectionOnPress,\n    ref: domRef,\n    ...domProps\n  } = usePressResponderContext(props);\n\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef<PressState>({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null,\n    disposables: []\n  });\n\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  let triggerPressStart = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return false;\n    }\n\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(true);\n    }\n\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n\n  let triggerPressEnd = useEffectEvent((originalEvent: EventBase, pointerType: PointerType, wasPressed = true) => {\n    let state = ref.current;\n    if (!state.didFirePressStart) {\n      return false;\n    }\n\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(false);\n    }\n\n    setPressed(false);\n\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation &&= event.shouldStopPropagation;\n    }\n\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n\n  let triggerPressUp = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return false;\n    }\n\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n\n    return true;\n  });\n\n  let cancel = useEffectEvent((e: EventBase) => {\n    let state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.didFirePressStart && state.pointerType != null) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target);\n      }\n      for (let dispose of state.disposables) {\n        dispose();\n      }\n      state.disposables = [];\n    }\n  });\n\n  let cancelOnPointerExit = useEffectEvent((e: EventBase) => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n\n  let triggerClick = useEffectEvent((e: RMouseEvent<FocusableElement>) => {\n    if (isDisabled) {\n      return;\n    }\n\n    onClick?.(e);\n  });\n\n  let triggerSyntheticClick = useEffectEvent((e: KeyboardEvent | TouchEvent, target: FocusableElement) => {\n    if (isDisabled) {\n      return;\n    }\n\n    // Some third-party libraries pass in onClick instead of onPress.\n    // Create a fake mouse event and trigger onClick as well.\n    // This matches the browser's native activation behavior for certain elements (e.g. button).\n    // https://html.spec.whatwg.org/#activation\n    // https://html.spec.whatwg.org/#fire-a-synthetic-pointer-event\n    if (onClick) {\n      let event = new MouseEvent('click', e);\n      setEventTarget(event, target);\n      onClick(createSyntheticEvent(event));\n    }\n  });\n\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps: DOMAttributes = {\n      onKeyDown(e) {\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          if (shouldPreventDefaultKeyboard(getEventTarget(e.nativeEvent), e.key)) {\n            e.preventDefault();\n          }\n\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            state.pointerType = 'keyboard';\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred. Make it capturing so that it will trigger\n            // before stopPropagation from useKeyboard on a child element may happen and thus we can still call triggerPress for the parent element.\n            let originalTarget = e.currentTarget;\n            let pressUp = (e) => {\n              if (isValidKeyboardEvent(e, originalTarget) && !e.repeat && nodeContains(originalTarget, getEventTarget(e)) && state.target) {\n                triggerPressUp(createEvent(state.target, e), 'keyboard');\n              }\n            };\n\n            addGlobalListener(getOwnerDocument(e.currentTarget), 'keyup', chain(pressUp, onKeyUp), true);\n          }\n\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && isMac()) {\n            state.metaKeyEvents?.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === 'Meta') {\n          state.metaKeyEvents = new Map();\n        }\n      },\n      onClick(e) {\n        if (e && !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(openLink as any).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n\n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || isVirtualClick(e.nativeEvent))) {\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            triggerClick(e);\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          } else if (state.isPressed && state.pointerType !== 'keyboard') {\n            let pointerType = state.pointerType || (e.nativeEvent as PointerEvent).pointerType as PointerType || 'virtual';\n            let stopPressUp = triggerPressUp(createEvent(e.currentTarget, e), pointerType);\n            let stopPressEnd =  triggerPressEnd(createEvent(e.currentTarget, e), pointerType, true);\n            shouldStopPropagation = stopPressUp && stopPressEnd;\n            state.isOverTarget = false;\n            triggerClick(e);\n            cancel(e);\n          }\n\n          state.ignoreEmulatedMouseEvents = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n\n    let onKeyUp = (e: KeyboardEvent) => {\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(getEventTarget(e), e.key)) {\n          e.preventDefault();\n        }\n\n        let target = getEventTarget(e);\n        let wasPressed = nodeContains(state.target, getEventTarget(e));\n        triggerPressEnd(createEvent(state.target, e), 'keyboard', wasPressed);\n        if (wasPressed) {\n          triggerSyntheticClick(e, state.target);\n        }\n        removeAllGlobalListeners();\n\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== 'Enter' && isHTMLAnchorLink(state.target) && nodeContains(state.target, target) && !e[LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n\n        state.isPressed = false;\n        state.metaKeyEvents?.delete(e.key);\n      } else if (e.key === 'Meta' && state.metaKeyEvents?.size) {\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (let event of events.values()) {\n          state.target?.dispatchEvent(new KeyboardEvent('keyup', event));\n        }\n      }\n    };\n\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = (e) => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n\n        state.pointerType = e.pointerType;\n\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget as FocusableElement;\n\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n\n          // Release pointer capture so that touch interactions can leave the original target.\n          // This enables onPointerLeave and onPointerEnter to fire.\n          let target = getEventTarget(e.nativeEvent);\n          if ('releasePointerCapture' in target) {\n            target.releasePointerCapture(e.pointerId);\n          }\n\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseDown = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (e.button === 0) {\n          if (preventFocusOnPress) {\n            let dispose = preventFocus(e.target as FocusableElement);\n            if (dispose) {\n              state.disposables.push(dispose);\n            }\n          }\n\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onPointerUp = (e) => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent)) || state.pointerType === 'virtual') {\n          return;\n        }\n\n        // Only handle left clicks. If isPressed is true, delay until onClick.\n        if (e.button === 0 && !state.isPressed) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n\n      pressProps.onPointerEnter = (e) => {\n        if (e.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = true;\n          triggerPressStart(createEvent(state.target, e), state.pointerType);\n        }\n      };\n\n      pressProps.onPointerLeave = (e) => {\n        if (e.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n\n      let onPointerUp = (e: PointerEvent) => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (nodeContains(state.target, getEventTarget(e)) && state.pointerType != null) {\n            // Wait for onClick to fire onPress. This avoids browser issues when the DOM\n            // is mutated between onPointerUp and onClick, and is more compatible with third party libraries.\n            // https://github.com/adobe/react-spectrum/issues/1513\n            // https://issues.chromium.org/issues/40732224\n            // However, iOS and Android do not focus or fire onClick after a long press.\n            // We work around this by triggering a click ourselves after a timeout.\n            // This timeout is canceled during the click event in case the real one fires first.\n            // The timeout must be at least 32ms, because Safari on iOS delays the click event on\n            // non-form elements without certain ARIA roles (for hover emulation).\n            // https://github.com/WebKit/WebKit/blob/dccfae42bb29bd4bdef052e469f604a9387241c0/Source/WebKit/WebProcess/WebPage/ios/WebPageIOS.mm#L875-L892\n            let clicked = false;\n            let timeout = setTimeout(() => {\n              if (state.isPressed && state.target instanceof HTMLElement) {\n                if (clicked) {\n                  cancel(e);\n                } else {\n                  focusWithoutScrolling(state.target);\n                  state.target.click();\n                }\n              }\n            }, 80);\n            // Use a capturing listener to track if a click occurred.\n            // If stopPropagation is called it may never reach our handler.\n            addGlobalListener(e.currentTarget as Document, 'click', () => clicked = true, true);\n            state.disposables.push(() => clearTimeout(timeout));\n          } else {\n            cancel(e);\n          }\n\n          // Ignore subsequent onPointerLeave event before onClick on touch devices.\n          state.isOverTarget = false;\n        }\n      };\n\n      let onPointerCancel = (e: PointerEvent) => {\n        cancel(e);\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      // NOTE: this fallback branch is entirely used by unit tests.\n      // All browsers now support pointer events, but JSDOM still does not.\n\n      pressProps.onMouseDown = (e) => {\n        // Only handle left clicks\n        if (e.button !== 0 || !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';\n\n        // Flush sync so that focus moved during react re-renders occurs before we yield back to the browser.\n        let shouldStopPropagation = flushSync(() => triggerPressStart(e, state.pointerType!));\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        if (preventFocusOnPress) {\n          let dispose = preventFocus(e.target as FocusableElement);\n          if (dispose) {\n            state.disposables.push(dispose);\n          }\n        }\n\n        addGlobalListener(getOwnerDocument(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n\n      pressProps.onMouseEnter = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseLeave = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseUp = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0 && !state.isPressed) {\n          triggerPressUp(e, state.pointerType || 'mouse');\n        }\n      };\n\n      let onMouseUp = (e: MouseEvent) => {\n        // Only handle left clicks\n        if (e.button !== 0) {\n          return;\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n\n        if (state.target && state.target.contains(e.target as Element) && state.pointerType != null) {\n          // Wait for onClick to fire onPress. This avoids browser issues when the DOM\n          // is mutated between onMouseUp and onClick, and is more compatible with third party libraries.\n        } else {\n          cancel(e);\n        }\n\n        state.isOverTarget = false;\n      };\n\n      pressProps.onTouchStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n\n        let shouldStopPropagation = triggerPressStart(createTouchEvent(state.target, e), state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerWindow(e.currentTarget), 'scroll', onScroll, true);\n      };\n\n      pressProps.onTouchMove = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(createTouchEvent(state.target!, e), state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType, false);\n          cancelOnPointerExit(createTouchEvent(state.target!, e));\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onTouchEnd = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp(createTouchEvent(state.target!, e), state.pointerType);\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType);\n          triggerSyntheticClick(e.nativeEvent, state.target!);\n        } else if (state.isOverTarget && state.pointerType != null) {\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n\n      pressProps.onTouchCancel = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(createTouchEvent(state.target!, e));\n        }\n      };\n\n      let onScroll = (e: Event) => {\n        if (state.isPressed && nodeContains(getEventTarget(e), state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        cancel(e);\n      };\n    }\n\n    return pressProps;\n  }, [\n    addGlobalListener,\n    isDisabled,\n    preventFocusOnPress,\n    removeAllGlobalListeners,\n    allowTextSelectionOnPress,\n    cancel,\n    cancelOnPointerExit,\n    triggerPressEnd,\n    triggerPressStart,\n    triggerPressUp,\n    triggerClick,\n    triggerSyntheticClick\n  ]);\n\n  // Avoid onClick delay for double tap to zoom by default.\n  useEffect(() => {\n    if (!domRef || process.env.NODE_ENV === 'test') {\n      return;\n    }\n\n    const ownerDocument = getOwnerDocument(domRef.current);\n    if (!ownerDocument || !ownerDocument.head || ownerDocument.getElementById(STYLE_ID)) {\n      return;\n    }\n\n    const style = ownerDocument.createElement('style');\n    style.id = STYLE_ID;\n    // touchAction: 'manipulation' is supposed to be equivalent, but in\n    // Safari it causes onPointerCancel not to fire on scroll.\n    // https://bugs.webkit.org/show_bug.cgi?id=240917\n    style.textContent = `\n@layer {\n  [${PRESSABLE_ATTRIBUTE}] {\n    touch-action: pan-x pan-y pinch-zoom;\n  }\n}\n    `.trim();\n    ownerDocument.head.prepend(style);\n  }, [domRef]);\n\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  useEffect(() => {\n    let state = ref.current;\n    return () => {\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target ?? undefined);\n      }\n      for (let dispose of state.disposables) {\n        dispose();\n      }\n      state.disposables = [];\n    };\n  }, [allowTextSelectionOnPress]);\n\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps, {[PRESSABLE_ATTRIBUTE]: true})\n  };\n}\n\nfunction isHTMLAnchorLink(target: Element): target is HTMLAnchorElement {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\n\nfunction isValidKeyboardEvent(event: KeyboardEvent, currentTarget: Element): boolean {\n  const {key, code} = event;\n  const element = currentTarget as HTMLElement;\n  const role = element.getAttribute('role');\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (\n    (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') &&\n    !((element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key)) ||\n      element instanceof getOwnerWindow(element).HTMLTextAreaElement ||\n      element.isContentEditable) &&\n    // Links should only trigger with Enter key\n    !((role === 'link' || (!role && isHTMLAnchorLink(element))) && key !== 'Enter')\n  );\n}\n\nfunction getTouchFromEvent(event: TouchEvent): Touch | null {\n  const {targetTouches} = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\n\nfunction getTouchById(\n  event: TouchEvent,\n  pointerId: null | number\n): null | Touch {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\n\nfunction createTouchEvent(target: FocusableElement, e: RTouchEvent<FocusableElement>): EventBase {\n  let clientX = 0;\n  let clientY = 0;\n  if (e.targetTouches && e.targetTouches.length === 1) {\n    clientX = e.targetTouches[0].clientX;\n    clientY = e.targetTouches[0].clientY;\n  }\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX,\n    clientY\n  };\n}\n\nfunction createEvent(target: FocusableElement, e: EventBase): EventBase {\n  let clientX = e.clientX;\n  let clientY = e.clientY;\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX,\n    clientY\n  };\n}\n\ninterface Rect {\n  top: number,\n  right: number,\n  bottom: number,\n  left: number\n}\n\ninterface EventPoint {\n  clientX: number,\n  clientY: number,\n  width?: number,\n  height?: number,\n  radiusX?: number,\n  radiusY?: number\n}\n\nfunction getPointClientRect(point: EventPoint): Rect {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) {\n    offsetX = (point.width / 2);\n  } else if (point.radiusX !== undefined) {\n    offsetX = point.radiusX;\n  }\n  if (point.height !== undefined) {\n    offsetY = (point.height / 2);\n  } else if (point.radiusY !== undefined) {\n    offsetY = point.radiusY;\n  }\n\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\n\nfunction areRectanglesOverlapping(a: Rect, b: Rect) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\n\nfunction isOverTarget(point: EventPoint, target: Element) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\n\nfunction shouldPreventDefaultUp(target: Element) {\n  if (target instanceof HTMLInputElement) {\n    return false;\n  }\n\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== 'submit' && target.type !== 'reset';\n  }\n\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction shouldPreventDefaultKeyboard(target: Element, key: string) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n\n  return shouldPreventDefaultUp(target);\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\nfunction isValidInputKey(target: HTMLInputElement, key: string) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio'\n    ? key === ' '\n    : nonTextInputTypes.has(target.type);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}