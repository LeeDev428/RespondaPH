{"ast":null,"code":"var _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar $g3RPq$react = require(\"react\");\nvar $g3RPq$reactariautils = require(\"@react-aria/utils\");\nvar $g3RPq$reactariainteractions = require(\"@react-aria/interactions\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"useSafelyMouseToSubmenu\", function () {\n  return $62347d8c4183e713$export$85ec83e04c95f50a;\n});\nvar $62347d8c4183e713$var$ALLOWED_INVALID_MOVEMENTS = 2;\nvar $62347d8c4183e713$var$THROTTLE_TIME = 50;\nvar $62347d8c4183e713$var$TIMEOUT_TIME = 1000;\nvar $62347d8c4183e713$var$ANGLE_PADDING = Math.PI / 12;\nfunction $62347d8c4183e713$export$85ec83e04c95f50a(options) {\n  var menuRef = options.menuRef,\n    submenuRef = options.submenuRef,\n    isOpen = options.isOpen,\n    isDisabled = options.isDisabled;\n  var prevPointerPos = (0, $g3RPq$react.useRef)(undefined);\n  var submenuRect = (0, $g3RPq$react.useRef)(undefined);\n  var lastProcessedTime = (0, $g3RPq$react.useRef)(0);\n  var timeout = (0, $g3RPq$react.useRef)(undefined);\n  var autoCloseTimeout = (0, $g3RPq$react.useRef)(undefined);\n  var submenuSide = (0, $g3RPq$react.useRef)(undefined);\n  var movementsTowardsSubmenuCount = (0, $g3RPq$react.useRef)(2);\n  var _ref = (0, $g3RPq$react.useState)(false),\n    _ref2 = _slicedToArray(_ref, 2),\n    preventPointerEvents = _ref2[0],\n    setPreventPointerEvents = _ref2[1];\n  var updateSubmenuRect = function updateSubmenuRect() {\n    if (submenuRef.current) {\n      submenuRect.current = submenuRef.current.getBoundingClientRect();\n      submenuSide.current = undefined;\n    }\n  };\n  (0, $g3RPq$reactariautils.useResizeObserver)({\n    ref: submenuRef,\n    onResize: updateSubmenuRect\n  });\n  var reset = function reset() {\n    setPreventPointerEvents(false);\n    movementsTowardsSubmenuCount.current = $62347d8c4183e713$var$ALLOWED_INVALID_MOVEMENTS;\n    prevPointerPos.current = undefined;\n  };\n  var modality = (0, $g3RPq$reactariainteractions.useInteractionModality)();\n  var onPointerDown = (0, $g3RPq$reactariautils.useEffectEvent)(function (e) {\n    if (preventPointerEvents) e.preventDefault();\n  });\n  (0, $g3RPq$react.useEffect)(function () {\n    if (preventPointerEvents && menuRef.current) menuRef.current.style.pointerEvents = 'none';else menuRef.current.style.pointerEvents = '';\n  }, [menuRef, preventPointerEvents]);\n  (0, $g3RPq$react.useEffect)(function () {\n    var submenu = submenuRef.current;\n    var menu = menuRef.current;\n    if (isDisabled || !submenu || !isOpen || modality !== 'pointer' || !menu) {\n      reset();\n      return;\n    }\n    submenuRect.current = submenu.getBoundingClientRect();\n    var onPointerMove = function onPointerMove(e) {\n      if (e.pointerType === 'touch' || e.pointerType === 'pen') return;\n      var currentTime = Date.now();\n      if (currentTime - lastProcessedTime.current < $62347d8c4183e713$var$THROTTLE_TIME) return;\n      clearTimeout(timeout.current);\n      clearTimeout(autoCloseTimeout.current);\n      var mouseX = e.clientX,\n        mouseY = e.clientY;\n      if (!prevPointerPos.current) {\n        prevPointerPos.current = {\n          x: mouseX,\n          y: mouseY\n        };\n        return;\n      }\n      if (!submenuRect.current) return;\n      if (!submenuSide.current) submenuSide.current = mouseX > submenuRect.current.right ? 'left' : 'right';\n      if (mouseX < menu.getBoundingClientRect().left || mouseX > menu.getBoundingClientRect().right || mouseY < menu.getBoundingClientRect().top || mouseY > menu.getBoundingClientRect().bottom) {\n        reset();\n        return;\n      }\n      var prevMouseX = prevPointerPos.current.x;\n      var prevMouseY = prevPointerPos.current.y;\n      var toSubmenuX = submenuSide.current === 'right' ? submenuRect.current.left - prevMouseX : prevMouseX - submenuRect.current.right;\n      var angleTop = Math.atan2(prevMouseY - submenuRect.current.top, toSubmenuX) + $62347d8c4183e713$var$ANGLE_PADDING;\n      var angleBottom = Math.atan2(prevMouseY - submenuRect.current.bottom, toSubmenuX) - $62347d8c4183e713$var$ANGLE_PADDING;\n      var anglePointer = Math.atan2(prevMouseY - mouseY, submenuSide.current === 'left' ? -(mouseX - prevMouseX) : mouseX - prevMouseX);\n      var isMovingTowardsSubmenu = anglePointer < angleTop && anglePointer > angleBottom;\n      movementsTowardsSubmenuCount.current = isMovingTowardsSubmenu ? Math.min(movementsTowardsSubmenuCount.current + 1, $62347d8c4183e713$var$ALLOWED_INVALID_MOVEMENTS) : Math.max(movementsTowardsSubmenuCount.current - 1, 0);\n      if (movementsTowardsSubmenuCount.current >= $62347d8c4183e713$var$ALLOWED_INVALID_MOVEMENTS) setPreventPointerEvents(true);else setPreventPointerEvents(false);\n      lastProcessedTime.current = currentTime;\n      prevPointerPos.current = {\n        x: mouseX,\n        y: mouseY\n      };\n      if (isMovingTowardsSubmenu) timeout.current = setTimeout(function () {\n        reset();\n        autoCloseTimeout.current = setTimeout(function () {\n          var target = document.elementFromPoint(mouseX, mouseY);\n          if (target && menu.contains(target)) target.dispatchEvent(new PointerEvent('pointerover', {\n            bubbles: true,\n            cancelable: true\n          }));\n        }, 100);\n      }, $62347d8c4183e713$var$TIMEOUT_TIME);\n    };\n    window.addEventListener('pointermove', onPointerMove);\n    if (process.env.NODE_ENV !== 'test') window.addEventListener('pointerdown', onPointerDown, true);\n    return function () {\n      window.removeEventListener('pointermove', onPointerMove);\n      if (process.env.NODE_ENV !== 'test') window.removeEventListener('pointerdown', onPointerDown, true);\n      clearTimeout(timeout.current);\n      clearTimeout(autoCloseTimeout.current);\n      movementsTowardsSubmenuCount.current = $62347d8c4183e713$var$ALLOWED_INVALID_MOVEMENTS;\n    };\n  }, [isDisabled, isOpen, menuRef, modality, setPreventPointerEvents, onPointerDown, submenuRef]);\n}","map":{"version":3,"names":["$62347d8c4183e713$var$ALLOWED_INVALID_MOVEMENTS","$62347d8c4183e713$var$THROTTLE_TIME","$62347d8c4183e713$var$TIMEOUT_TIME","$62347d8c4183e713$var$ANGLE_PADDING","Math","PI","$62347d8c4183e713$export$85ec83e04c95f50a","options","menuRef","submenuRef","isOpen","isDisabled","prevPointerPos","$g3RPq$react","useRef","undefined","submenuRect","lastProcessedTime","timeout","autoCloseTimeout","submenuSide","movementsTowardsSubmenuCount","_ref","useState","_ref2","_slicedToArray","preventPointerEvents","setPreventPointerEvents","updateSubmenuRect","current","getBoundingClientRect","$g3RPq$reactariautils","useResizeObserver","ref","onResize","reset","modality","$g3RPq$reactariainteractions","useInteractionModality","onPointerDown","useEffectEvent","e","preventDefault","useEffect","style","pointerEvents","submenu","menu","onPointerMove","pointerType","currentTime","Date","now","clearTimeout","mouseX","clientX","mouseY","clientY","x","y","right","left","top","bottom","prevMouseX","prevMouseY","toSubmenuX","angleTop","atan2","angleBottom","anglePointer","isMovingTowardsSubmenu","min","max","setTimeout","target","document","elementFromPoint","contains","dispatchEvent","PointerEvent","bubbles","cancelable","window","addEventListener","process","env","NODE_ENV","removeEventListener"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\menu\\dist\\packages\\@react-aria\\menu\\src\\useSafelyMouseToSubmenu.ts"],"sourcesContent":["\nimport {RefObject} from '@react-types/shared';\nimport {useEffect, useRef, useState} from 'react';\nimport {useEffectEvent, useResizeObserver} from '@react-aria/utils';\nimport {useInteractionModality} from '@react-aria/interactions';\n\ninterface SafelyMouseToSubmenuOptions {\n  /** Ref for the parent menu. */\n  menuRef: RefObject<Element | null>,\n  /** Ref for the submenu. */\n  submenuRef: RefObject<Element | null>,\n  /** Whether the submenu is open. */\n  isOpen: boolean,\n  /** Whether this feature is disabled. */\n  isDisabled?: boolean\n}\n\nconst ALLOWED_INVALID_MOVEMENTS = 2;\nconst THROTTLE_TIME = 50;\nconst TIMEOUT_TIME = 1000;\nconst ANGLE_PADDING = Math.PI / 12; // 15Â°\n\n/**\n * Allows the user to move their pointer to the submenu without it closing when their mouse leaves the trigger element.\n * Prevents pointer events from going to the underlying menu if the user is moving their pointer towards the sub-menu.\n */\nexport function useSafelyMouseToSubmenu(options: SafelyMouseToSubmenuOptions): void {\n  let {menuRef, submenuRef, isOpen, isDisabled} = options;\n  let prevPointerPos = useRef<{x: number, y: number} | undefined>(undefined);\n  let submenuRect = useRef<DOMRect | undefined>(undefined);\n  let lastProcessedTime = useRef<number>(0);\n  let timeout = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  let autoCloseTimeout = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  let submenuSide = useRef<'left' | 'right' | undefined>(undefined);\n  let movementsTowardsSubmenuCount = useRef<number>(2);\n  let [preventPointerEvents, setPreventPointerEvents] = useState(false);\n\n  let updateSubmenuRect = () => {\n    if (submenuRef.current) {\n      submenuRect.current = submenuRef.current.getBoundingClientRect();\n      submenuSide.current = undefined;\n    }\n  };\n  useResizeObserver({ref: submenuRef, onResize: updateSubmenuRect});\n\n  let reset = () => {\n    setPreventPointerEvents(false);\n    movementsTowardsSubmenuCount.current = ALLOWED_INVALID_MOVEMENTS;\n    prevPointerPos.current = undefined;\n  };\n\n  let modality = useInteractionModality();\n\n  // Prevent mouse down over safe triangle. Clicking while pointer-events: none is applied\n  // will cause focus to move unexpectedly since it will go to an element behind the menu.\n  let onPointerDown = useEffectEvent((e: PointerEvent) => {\n    if (preventPointerEvents) {\n      e.preventDefault();\n    }\n  });\n\n  useEffect(() => {\n    if (preventPointerEvents && menuRef.current) {\n      (menuRef.current as HTMLElement).style.pointerEvents = 'none';\n    } else {\n      (menuRef.current as HTMLElement).style.pointerEvents = '';\n    }\n  }, [menuRef, preventPointerEvents]);\n\n  useEffect(() => {\n    let submenu = submenuRef.current;\n    let menu = menuRef.current;\n\n    if (isDisabled || !submenu || !isOpen || modality !== 'pointer' || !menu) {\n      reset();\n      return;\n    }\n    submenuRect.current = submenu.getBoundingClientRect();\n\n    let onPointerMove = (e: PointerEvent) => {\n      if (e.pointerType === 'touch' || e.pointerType === 'pen') {\n        return;\n      }\n\n      let currentTime = Date.now();\n\n      // Throttle\n      if (currentTime - lastProcessedTime.current < THROTTLE_TIME) {\n        return;\n      }\n      clearTimeout(timeout.current);\n      clearTimeout(autoCloseTimeout.current);\n\n      let {clientX: mouseX, clientY: mouseY} = e;\n\n      if (!prevPointerPos.current) {\n        prevPointerPos.current = {x: mouseX, y: mouseY};\n        return;\n      }\n\n      if (!submenuRect.current) {\n        return;\n      }\n\n      if (!submenuSide.current) {\n        submenuSide.current = mouseX > submenuRect.current.right ? 'left' : 'right';\n      }\n\n      // Pointer is outside of parent menu\n      if (mouseX < menu.getBoundingClientRect().left || mouseX > menu.getBoundingClientRect().right || mouseY < menu.getBoundingClientRect().top || mouseY > menu.getBoundingClientRect().bottom) {\n        reset();\n        return;\n      }\n\n      /* Check if pointer is moving towards submenu.\n        Uses the 2-argument arctangent (https://en.wikipedia.org/wiki/Atan2) to calculate:\n          - angle between previous pointer and top of submenu\n          - angle between previous pointer and bottom of submenu\n          - angle between previous pointer and current pointer (delta)\n        If the pointer delta angle value is between the top and bottom angle values, we know the pointer is moving towards the submenu.\n      */\n      let prevMouseX = prevPointerPos.current.x;\n      let prevMouseY = prevPointerPos.current.y;\n      let toSubmenuX = submenuSide.current === 'right' ? submenuRect.current.left - prevMouseX : prevMouseX - submenuRect.current.right;\n      let angleTop = Math.atan2(prevMouseY - submenuRect.current.top, toSubmenuX) + ANGLE_PADDING;\n      let angleBottom = Math.atan2(prevMouseY - submenuRect.current.bottom, toSubmenuX) - ANGLE_PADDING;\n      let anglePointer = Math.atan2(prevMouseY - mouseY, (submenuSide.current === 'left' ? -(mouseX - prevMouseX) : mouseX - prevMouseX));\n      let isMovingTowardsSubmenu = anglePointer < angleTop && anglePointer > angleBottom;\n\n      movementsTowardsSubmenuCount.current = isMovingTowardsSubmenu ?\n        Math.min(movementsTowardsSubmenuCount.current + 1, ALLOWED_INVALID_MOVEMENTS) :\n        Math.max(movementsTowardsSubmenuCount.current - 1, 0);\n\n      if (movementsTowardsSubmenuCount.current >= ALLOWED_INVALID_MOVEMENTS) {\n        setPreventPointerEvents(true);\n      } else {\n        setPreventPointerEvents(false);\n      }\n\n      lastProcessedTime.current = currentTime;\n      prevPointerPos.current = {x: mouseX, y: mouseY};\n\n      // If the pointer is moving towards the submenu, start a timeout to close if no other movements are made after 500ms.\n      if (isMovingTowardsSubmenu) {\n        timeout.current = setTimeout(() => {\n          reset();\n          autoCloseTimeout.current = setTimeout(() => {\n            // Fire a pointerover event to trigger the menu to close.\n            // Wait until pointer-events:none is no longer applied\n            let target = document.elementFromPoint(mouseX, mouseY);\n            if (target && menu.contains(target)) {\n              target.dispatchEvent(new PointerEvent('pointerover', {bubbles: true, cancelable: true}));\n            }\n          }, 100);\n        }, TIMEOUT_TIME);\n      }\n    };\n\n    window.addEventListener('pointermove', onPointerMove);\n\n    // Prevent pointer down over the safe triangle. See above comment.\n    // Do not enable in tests, because JSDom doesn't do hit testing.\n    if (process.env.NODE_ENV !== 'test') {\n      window.addEventListener('pointerdown', onPointerDown, true);\n    }\n\n    return () => {\n      window.removeEventListener('pointermove', onPointerMove);\n      if (process.env.NODE_ENV !== 'test') {\n        window.removeEventListener('pointerdown', onPointerDown, true);\n      }\n      clearTimeout(timeout.current);\n      clearTimeout(autoCloseTimeout.current);\n      movementsTowardsSubmenuCount.current = ALLOWED_INVALID_MOVEMENTS;\n    };\n\n  }, [isDisabled, isOpen, menuRef, modality, setPreventPointerEvents, onPointerDown, submenuRef]);\n}\n"],"mappings":";;;;;;;;;;;;;;;AAiBA,IAAMA,+CAAA,GAA4B;AAClC,IAAMC,mCAAA,GAAgB;AACtB,IAAMC,kCAAA,GAAe;AACrB,IAAMC,mCAAA,GAAgBC,IAAA,CAAKC,EAAE,GAAG;AAMzB,SAASC,0CAAwBC,OAAoC;EAC1E,IAAKC,OAAO,GAAoCD,OAAA,CAA5CC,OAAA;IAAUC,UAAU,GAAwBF,OAAA,CAApCE,UAAA;IAAcC,MAAM,GAAgBH,OAAA,CAAxBG,MAAA;IAAUC,UAAU,GAAIJ,OAAA,CAAhBI,UAAA;EAChC,IAAIC,cAAA,GAAiB,IAAAC,YAAA,CAAAC,MAAK,EAAsCC,SAAA;EAChE,IAAIC,WAAA,GAAc,IAAAH,YAAA,CAAAC,MAAK,EAAuBC,SAAA;EAC9C,IAAIE,iBAAA,GAAoB,IAAAJ,YAAA,CAAAC,MAAK,EAAU;EACvC,IAAII,OAAA,GAAU,IAAAL,YAAA,CAAAC,MAAK,EAA6CC,SAAA;EAChE,IAAII,gBAAA,GAAmB,IAAAN,YAAA,CAAAC,MAAK,EAA6CC,SAAA;EACzE,IAAIK,WAAA,GAAc,IAAAP,YAAA,CAAAC,MAAK,EAAgCC,SAAA;EACvD,IAAIM,4BAAA,GAA+B,IAAAR,YAAA,CAAAC,MAAK,EAAU;EAClD,IAAAQ,IAAA,GAAsD,IAAAT,YAAA,CAAAU,QAAO,EAAE;IAAAC,KAAA,GAAAC,cAAA,CAAAH,IAAA;IAA1DI,oBAAA,GAAAF,KAAA;IAAsBG,uBAAA,GAAAH,KAAA;EAE3B,IAAII,iBAAA,GAAoB,SAApBA,kBAAA,EAAoB;IACtB,IAAInB,UAAA,CAAWoB,OAAO,EAAE;MACtBb,WAAA,CAAYa,OAAO,GAAGpB,UAAA,CAAWoB,OAAO,CAACC,qBAAqB;MAC9DV,WAAA,CAAYS,OAAO,GAAGd,SAAA;IACxB;EACF;EACA,IAAAgB,qBAAA,CAAAC,iBAAgB,EAAE;IAACC,GAAA,EAAKxB,UAAA;IAAYyB,QAAA,EAAUN;EAAiB;EAE/D,IAAIO,KAAA,GAAQ,SAARA,MAAA,EAAQ;IACVR,uBAAA,CAAwB;IACxBN,4BAAA,CAA6BQ,OAAO,GAAG7B,+CAAA;IACvCY,cAAA,CAAeiB,OAAO,GAAGd,SAAA;EAC3B;EAEA,IAAIqB,QAAA,GAAW,IAAAC,4BAAA,CAAAC,sBAAqB;EAIpC,IAAIC,aAAA,GAAgB,IAAAR,qBAAA,CAAAS,cAAa,EAAE,UAACC,CAAA;IAClC,IAAIf,oBAAA,EACFe,CAAA,CAAEC,cAAc;EAEpB;EAEA,IAAA7B,YAAA,CAAA8B,SAAQ,EAAE;IACR,IAAIjB,oBAAA,IAAwBlB,OAAA,CAAQqB,OAAO,EACzCrB,OAAC,CAAQqB,OAAO,CAAiBe,KAAK,CAACC,aAAa,GAAG,YAEvDrC,OAAC,CAAQqB,OAAO,CAAiBe,KAAK,CAACC,aAAa,GAAG;EAE3D,GAAG,CAACrC,OAAA,EAASkB,oBAAA,CAAqB;EAElC,IAAAb,YAAA,CAAA8B,SAAQ,EAAE;IACR,IAAIG,OAAA,GAAUrC,UAAA,CAAWoB,OAAO;IAChC,IAAIkB,IAAA,GAAOvC,OAAA,CAAQqB,OAAO;IAE1B,IAAIlB,UAAA,IAAc,CAACmC,OAAA,IAAW,CAACpC,MAAA,IAAU0B,QAAA,KAAa,aAAa,CAACW,IAAA,EAAM;MACxEZ,KAAA;MACA;IACF;IACAnB,WAAA,CAAYa,OAAO,GAAGiB,OAAA,CAAQhB,qBAAqB;IAEnD,IAAIkB,aAAA,GAAgB,SAAhBA,cAAiBP,CAAA;MACnB,IAAIA,CAAA,CAAEQ,WAAW,KAAK,WAAWR,CAAA,CAAEQ,WAAW,KAAK,OACjD;MAGF,IAAIC,WAAA,GAAcC,IAAA,CAAKC,GAAG;MAG1B,IAAIF,WAAA,GAAcjC,iBAAA,CAAkBY,OAAO,GAAG5B,mCAAA,EAC5C;MAEFoD,YAAA,CAAanC,OAAA,CAAQW,OAAO;MAC5BwB,YAAA,CAAalC,gBAAA,CAAiBU,OAAO;MAErC,IAAcyB,MAAM,GAAqBb,CAAA,CAApCc,OAAA;QAA0BC,MAAM,GAAIf,CAAA,CAAnBgB,OAAA;MAEtB,IAAI,CAAC7C,cAAA,CAAeiB,OAAO,EAAE;QAC3BjB,cAAA,CAAeiB,OAAO,GAAG;UAAC6B,CAAA,EAAGJ,MAAA;UAAQK,CAAA,EAAGH;QAAM;QAC9C;MACF;MAEA,IAAI,CAACxC,WAAA,CAAYa,OAAO,EACtB;MAGF,IAAI,CAACT,WAAA,CAAYS,OAAO,EACtBT,WAAA,CAAYS,OAAO,GAAGyB,MAAA,GAAStC,WAAA,CAAYa,OAAO,CAAC+B,KAAK,GAAG,SAAS;MAItE,IAAIN,MAAA,GAASP,IAAA,CAAKjB,qBAAqB,GAAG+B,IAAI,IAAIP,MAAA,GAASP,IAAA,CAAKjB,qBAAqB,GAAG8B,KAAK,IAAIJ,MAAA,GAAST,IAAA,CAAKjB,qBAAqB,GAAGgC,GAAG,IAAIN,MAAA,GAAST,IAAA,CAAKjB,qBAAqB,GAAGiC,MAAM,EAAE;QAC1L5B,KAAA;QACA;MACF;MASA,IAAI6B,UAAA,GAAapD,cAAA,CAAeiB,OAAO,CAAC6B,CAAC;MACzC,IAAIO,UAAA,GAAarD,cAAA,CAAeiB,OAAO,CAAC8B,CAAC;MACzC,IAAIO,UAAA,GAAa9C,WAAA,CAAYS,OAAO,KAAK,UAAUb,WAAA,CAAYa,OAAO,CAACgC,IAAI,GAAGG,UAAA,GAAaA,UAAA,GAAahD,WAAA,CAAYa,OAAO,CAAC+B,KAAK;MACjI,IAAIO,QAAA,GAAW/D,IAAA,CAAKgE,KAAK,CAACH,UAAA,GAAajD,WAAA,CAAYa,OAAO,CAACiC,GAAG,EAAEI,UAAA,IAAc/D,mCAAA;MAC9E,IAAIkE,WAAA,GAAcjE,IAAA,CAAKgE,KAAK,CAACH,UAAA,GAAajD,WAAA,CAAYa,OAAO,CAACkC,MAAM,EAAEG,UAAA,IAAc/D,mCAAA;MACpF,IAAImE,YAAA,GAAelE,IAAA,CAAKgE,KAAK,CAACH,UAAA,GAAaT,MAAA,EAASpC,WAAA,CAAYS,OAAO,KAAK,SAAS,EAAEyB,MAAA,GAASU,UAAS,IAAKV,MAAA,GAASU,UAAA;MACvH,IAAIO,sBAAA,GAAyBD,YAAA,GAAeH,QAAA,IAAYG,YAAA,GAAeD,WAAA;MAEvEhD,4BAAA,CAA6BQ,OAAO,GAAG0C,sBAAA,GACrCnE,IAAA,CAAKoE,GAAG,CAACnD,4BAAA,CAA6BQ,OAAO,GAAG,GAAG7B,+CAAA,IACnDI,IAAA,CAAKqE,GAAG,CAACpD,4BAAA,CAA6BQ,OAAO,GAAG,GAAG;MAErD,IAAIR,4BAAA,CAA6BQ,OAAO,IAAI7B,+CAAA,EAC1C2B,uBAAA,CAAwB,WAExBA,uBAAA,CAAwB;MAG1BV,iBAAA,CAAkBY,OAAO,GAAGqB,WAAA;MAC5BtC,cAAA,CAAeiB,OAAO,GAAG;QAAC6B,CAAA,EAAGJ,MAAA;QAAQK,CAAA,EAAGH;MAAM;MAG9C,IAAIe,sBAAA,EACFrD,OAAA,CAAQW,OAAO,GAAG6C,UAAA,CAAW;QAC3BvC,KAAA;QACAhB,gBAAA,CAAiBU,OAAO,GAAG6C,UAAA,CAAW;UAGpC,IAAIC,MAAA,GAASC,QAAA,CAASC,gBAAgB,CAACvB,MAAA,EAAQE,MAAA;UAC/C,IAAImB,MAAA,IAAU5B,IAAA,CAAK+B,QAAQ,CAACH,MAAA,GAC1BA,MAAA,CAAOI,aAAa,CAAC,IAAIC,YAAA,CAAa,eAAe;YAACC,OAAA,EAAS;YAAMC,UAAA,EAAY;UAAI;QAEzF,GAAG;MACL,GAAGhF,kCAAA;IAEP;IAEAiF,MAAA,CAAOC,gBAAgB,CAAC,eAAepC,aAAA;IAIvC,IAAIqC,OAAA,CAAQC,GAAG,CAACC,QAAQ,KAAK,QAC3BJ,MAAA,CAAOC,gBAAgB,CAAC,eAAe7C,aAAA,EAAe;IAGxD,OAAO;MACL4C,MAAA,CAAOK,mBAAmB,CAAC,eAAexC,aAAA;MAC1C,IAAIqC,OAAA,CAAQC,GAAG,CAACC,QAAQ,KAAK,QAC3BJ,MAAA,CAAOK,mBAAmB,CAAC,eAAejD,aAAA,EAAe;MAE3Dc,YAAA,CAAanC,OAAA,CAAQW,OAAO;MAC5BwB,YAAA,CAAalC,gBAAA,CAAiBU,OAAO;MACrCR,4BAAA,CAA6BQ,OAAO,GAAG7B,+CAAA;IACzC;EAEF,GAAG,CAACW,UAAA,EAAYD,MAAA,EAAQF,OAAA,EAAS4B,QAAA,EAAUT,uBAAA,EAAyBY,aAAA,EAAe9B,UAAA,CAAW;AAChG","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}