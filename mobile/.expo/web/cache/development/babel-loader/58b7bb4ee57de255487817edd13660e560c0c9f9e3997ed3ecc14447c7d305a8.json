{"ast":null,"code":"var _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar $8d1e5da058b86bb9$exports = require(\"./intlStrings.main.js\");\nvar $BGXP4$reactarialiveannouncer = require(\"@react-aria/live-announcer\");\nvar $BGXP4$reactariaoverlays = require(\"@react-aria/overlays\");\nvar $BGXP4$reactarialistbox = require(\"@react-aria/listbox\");\nvar $BGXP4$reactariautils = require(\"@react-aria/utils\");\nvar $BGXP4$reactariafocus = require(\"@react-aria/focus\");\nvar $BGXP4$react = require(\"react\");\nvar $BGXP4$reactstatelycollections = require(\"@react-stately/collections\");\nvar $BGXP4$reactariaselection = require(\"@react-aria/selection\");\nvar $BGXP4$reactstatelyform = require(\"@react-stately/form\");\nvar $BGXP4$reactariai18n = require(\"@react-aria/i18n\");\nvar $BGXP4$reactariamenu = require(\"@react-aria/menu\");\nvar $BGXP4$reactariatextfield = require(\"@react-aria/textfield\");\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"useComboBox\", function () {\n  return $242452271d1e4c0e$export$8c18d1b4f7232bbf;\n});\nfunction $242452271d1e4c0e$export$8c18d1b4f7232bbf(props, state) {\n  var buttonRef = props.buttonRef,\n    popoverRef = props.popoverRef,\n    inputRef = props.inputRef,\n    listBoxRef = props.listBoxRef,\n    keyboardDelegate = props.keyboardDelegate,\n    layoutDelegate = props.layoutDelegate,\n    shouldFocusWrap = props.shouldFocusWrap,\n    isReadOnly = props.isReadOnly,\n    isDisabled = props.isDisabled;\n  var backupBtnRef = (0, $BGXP4$react.useRef)(null);\n  buttonRef = buttonRef !== null && buttonRef !== void 0 ? buttonRef : backupBtnRef;\n  var stringFormatter = (0, $BGXP4$reactariai18n.useLocalizedStringFormatter)((0, $parcel$interopDefault($8d1e5da058b86bb9$exports)), '@react-aria/combobox');\n  var _ref2 = (0, $BGXP4$reactariamenu.useMenuTrigger)({\n      type: 'listbox',\n      isDisabled: isDisabled || isReadOnly\n    }, state, buttonRef),\n    menuTriggerProps = _ref2.menuTriggerProps,\n    menuProps = _ref2.menuProps;\n  (0, $BGXP4$reactarialistbox.listData).set(state, {\n    id: menuProps.id\n  });\n  var collection = state.collection;\n  var disabledKeys = state.selectionManager.disabledKeys;\n  var delegate = (0, $BGXP4$react.useMemo)(function () {\n    return keyboardDelegate || new (0, $BGXP4$reactariaselection.ListKeyboardDelegate)({\n      collection: collection,\n      disabledKeys: disabledKeys,\n      ref: listBoxRef,\n      layoutDelegate: layoutDelegate\n    });\n  }, [keyboardDelegate, layoutDelegate, collection, disabledKeys, listBoxRef]);\n  var _ref3 = (0, $BGXP4$reactariaselection.useSelectableCollection)({\n      selectionManager: state.selectionManager,\n      keyboardDelegate: delegate,\n      disallowTypeAhead: true,\n      disallowEmptySelection: true,\n      shouldFocusWrap: shouldFocusWrap,\n      ref: inputRef,\n      isVirtualized: true\n    }),\n    collectionProps = _ref3.collectionProps;\n  var router = (0, $BGXP4$reactariautils.useRouter)();\n  var onKeyDown = function onKeyDown(e) {\n    if (e.nativeEvent.isComposing) return;\n    switch (e.key) {\n      case 'Enter':\n      case 'Tab':\n        if (state.isOpen && e.key === 'Enter') e.preventDefault();\n        if (state.isOpen && listBoxRef.current && state.selectionManager.focusedKey != null) {\n          var collectionItem = state.collection.getItem(state.selectionManager.focusedKey);\n          if (collectionItem === null || collectionItem === void 0 ? void 0 : collectionItem.props.href) {\n            var item = listBoxRef.current.querySelector(`[data-key=\"${CSS.escape(state.selectionManager.focusedKey.toString())}\"]`);\n            if (e.key === 'Enter' && item instanceof HTMLAnchorElement) router.open(item, e, collectionItem.props.href, collectionItem.props.routerOptions);\n            state.close();\n            break;\n          } else if (collectionItem === null || collectionItem === void 0 ? void 0 : collectionItem.props.onAction) {\n            collectionItem.props.onAction();\n            state.close();\n            break;\n          }\n        }\n        state.commit();\n        break;\n      case 'Escape':\n        if (state.selectedKey !== null || state.inputValue === '' || props.allowsCustomValue) e.continuePropagation();\n        state.revert();\n        break;\n      case 'ArrowDown':\n        state.open('first', 'manual');\n        break;\n      case 'ArrowUp':\n        state.open('last', 'manual');\n        break;\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        state.selectionManager.setFocusedKey(null);\n        break;\n    }\n  };\n  var onBlur = function onBlur(e) {\n    var _popoverRef_current;\n    var blurFromButton = (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) && buttonRef.current === e.relatedTarget;\n    var blurIntoPopover = (_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(e.relatedTarget);\n    if (blurFromButton || blurIntoPopover) return;\n    if (props.onBlur) props.onBlur(e);\n    state.setFocused(false);\n  };\n  var onFocus = function onFocus(e) {\n    if (state.isFocused) return;\n    if (props.onFocus) props.onFocus(e);\n    state.setFocused(true);\n  };\n  var _state$displayValidat = state.displayValidation,\n    isInvalid = _state$displayValidat.isInvalid,\n    validationErrors = _state$displayValidat.validationErrors,\n    validationDetails = _state$displayValidat.validationDetails;\n  var _ref4 = (0, $BGXP4$reactariatextfield.useTextField)(Object.assign({}, props, _defineProperty({\n      onChange: state.setInputValue,\n      onKeyDown: !isReadOnly ? (0, $BGXP4$reactariautils.chain)(state.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown) : props.onKeyDown,\n      onBlur: onBlur,\n      value: state.inputValue,\n      defaultValue: state.defaultInputValue,\n      onFocus: onFocus,\n      autoComplete: 'off',\n      validate: undefined\n    }, (0, $BGXP4$reactstatelyform.privateValidationStateProp), state)), inputRef),\n    labelProps = _ref4.labelProps,\n    inputProps = _ref4.inputProps,\n    descriptionProps = _ref4.descriptionProps,\n    errorMessageProps = _ref4.errorMessageProps;\n  var onPress = function onPress(e) {\n    if (e.pointerType === 'touch') {\n      var _inputRef_current;\n      (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();\n      state.toggle(null, 'manual');\n    }\n  };\n  var onPressStart = function onPressStart(e) {\n    if (e.pointerType !== 'touch') {\n      var _inputRef_current;\n      (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();\n      state.toggle(e.pointerType === 'keyboard' || e.pointerType === 'virtual' ? 'first' : null, 'manual');\n    }\n  };\n  var triggerLabelProps = (0, $BGXP4$reactariautils.useLabels)({\n    id: menuTriggerProps.id,\n    'aria-label': stringFormatter.format('buttonLabel'),\n    'aria-labelledby': props['aria-labelledby'] || labelProps.id\n  });\n  var listBoxProps = (0, $BGXP4$reactariautils.useLabels)({\n    id: menuProps.id,\n    'aria-label': stringFormatter.format('listboxLabel'),\n    'aria-labelledby': props['aria-labelledby'] || labelProps.id\n  });\n  var lastEventTime = (0, $BGXP4$react.useRef)(0);\n  var onTouchEnd = function onTouchEnd(e) {\n    if (isDisabled || isReadOnly) return;\n    if (e.timeStamp - lastEventTime.current < 500) {\n      var _inputRef_current;\n      e.preventDefault();\n      (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();\n      return;\n    }\n    var rect = e.target.getBoundingClientRect();\n    var touch = e.changedTouches[0];\n    var centerX = Math.ceil(rect.left + .5 * rect.width);\n    var centerY = Math.ceil(rect.top + .5 * rect.height);\n    if (touch.clientX === centerX && touch.clientY === centerY) {\n      var _inputRef_current1;\n      e.preventDefault();\n      (_inputRef_current1 = inputRef.current) === null || _inputRef_current1 === void 0 ? void 0 : _inputRef_current1.focus();\n      state.toggle(null, 'manual');\n      lastEventTime.current = e.timeStamp;\n    }\n  };\n  var focusedItem = state.selectionManager.focusedKey != null && state.isOpen ? state.collection.getItem(state.selectionManager.focusedKey) : undefined;\n  var _focusedItem_parentKey;\n  var sectionKey = (_focusedItem_parentKey = focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.parentKey) !== null && _focusedItem_parentKey !== void 0 ? _focusedItem_parentKey : null;\n  var _state_selectionManager_focusedKey;\n  var itemKey = (_state_selectionManager_focusedKey = state.selectionManager.focusedKey) !== null && _state_selectionManager_focusedKey !== void 0 ? _state_selectionManager_focusedKey : null;\n  var lastSection = (0, $BGXP4$react.useRef)(sectionKey);\n  var lastItem = (0, $BGXP4$react.useRef)(itemKey);\n  (0, $BGXP4$react.useEffect)(function () {\n    if ((0, $BGXP4$reactariautils.isAppleDevice)() && focusedItem != null && itemKey != null && itemKey !== lastItem.current) {\n      var isSelected = state.selectionManager.isSelected(itemKey);\n      var section = sectionKey != null ? state.collection.getItem(sectionKey) : null;\n      var sectionTitle = (section === null || section === void 0 ? void 0 : section['aria-label']) || (typeof (section === null || section === void 0 ? void 0 : section.rendered) === 'string' ? section.rendered : '') || '';\n      var _ref;\n      var announcement = stringFormatter.format('focusAnnouncement', {\n        isGroupChange: (_ref = section && sectionKey !== lastSection.current) !== null && _ref !== void 0 ? _ref : false,\n        groupTitle: sectionTitle,\n        groupCount: section ? _toConsumableArray((0, $BGXP4$reactstatelycollections.getChildNodes)(section, state.collection)).length : 0,\n        optionText: focusedItem['aria-label'] || focusedItem.textValue || '',\n        isSelected: isSelected\n      });\n      (0, $BGXP4$reactarialiveannouncer.announce)(announcement);\n    }\n    lastSection.current = sectionKey;\n    lastItem.current = itemKey;\n  });\n  var optionCount = (0, $BGXP4$reactstatelycollections.getItemCount)(state.collection);\n  var lastSize = (0, $BGXP4$react.useRef)(optionCount);\n  var lastOpen = (0, $BGXP4$react.useRef)(state.isOpen);\n  (0, $BGXP4$react.useEffect)(function () {\n    var didOpenWithoutFocusedItem = state.isOpen !== lastOpen.current && (state.selectionManager.focusedKey == null || (0, $BGXP4$reactariautils.isAppleDevice)());\n    if (state.isOpen && (didOpenWithoutFocusedItem || optionCount !== lastSize.current)) {\n      var announcement = stringFormatter.format('countAnnouncement', {\n        optionCount: optionCount\n      });\n      (0, $BGXP4$reactarialiveannouncer.announce)(announcement);\n    }\n    lastSize.current = optionCount;\n    lastOpen.current = state.isOpen;\n  });\n  var lastSelectedKey = (0, $BGXP4$react.useRef)(state.selectedKey);\n  (0, $BGXP4$react.useEffect)(function () {\n    if ((0, $BGXP4$reactariautils.isAppleDevice)() && state.isFocused && state.selectedItem && state.selectedKey !== lastSelectedKey.current) {\n      var optionText = state.selectedItem['aria-label'] || state.selectedItem.textValue || '';\n      var announcement = stringFormatter.format('selectedAnnouncement', {\n        optionText: optionText\n      });\n      (0, $BGXP4$reactarialiveannouncer.announce)(announcement);\n    }\n    lastSelectedKey.current = state.selectedKey;\n  });\n  (0, $BGXP4$react.useEffect)(function () {\n    if (state.isOpen) return (0, $BGXP4$reactariaoverlays.ariaHideOutside)([inputRef.current, popoverRef.current].filter(function (element) {\n      return element != null;\n    }));\n  }, [state.isOpen, inputRef, popoverRef]);\n  (0, $BGXP4$reactariautils.useUpdateEffect)(function () {\n    if (!focusedItem && inputRef.current && (0, $BGXP4$reactariautils.getActiveElement)((0, $BGXP4$reactariautils.getOwnerDocument)(inputRef.current)) === inputRef.current) (0, $BGXP4$reactariafocus.dispatchVirtualFocus)(inputRef.current, null);\n  }, [focusedItem]);\n  (0, $BGXP4$reactariautils.useEvent)(listBoxRef, 'react-aria-item-action', state.isOpen ? function () {\n    state.close();\n  } : undefined);\n  return {\n    labelProps: labelProps,\n    buttonProps: Object.assign({}, menuTriggerProps, triggerLabelProps, {\n      excludeFromTabOrder: true,\n      preventFocusOnPress: true,\n      onPress: onPress,\n      onPressStart: onPressStart,\n      isDisabled: isDisabled || isReadOnly\n    }),\n    inputProps: (0, $BGXP4$reactariautils.mergeProps)(inputProps, {\n      role: 'combobox',\n      'aria-expanded': menuTriggerProps['aria-expanded'],\n      'aria-controls': state.isOpen ? menuProps.id : undefined,\n      'aria-autocomplete': 'list',\n      'aria-activedescendant': focusedItem ? (0, $BGXP4$reactarialistbox.getItemId)(state, focusedItem.key) : undefined,\n      onTouchEnd: onTouchEnd,\n      autoCorrect: 'off',\n      spellCheck: 'false'\n    }),\n    listBoxProps: (0, $BGXP4$reactariautils.mergeProps)(menuProps, listBoxProps, _defineProperty({\n      autoFocus: state.focusStrategy || true,\n      shouldUseVirtualFocus: true,\n      shouldSelectOnPressUp: true,\n      shouldFocusOnHover: true,\n      linkBehavior: 'selection'\n    }, 'UNSTABLE_itemBehavior', 'action')),\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps,\n    isInvalid: isInvalid,\n    validationErrors: validationErrors,\n    validationDetails: validationDetails\n  };\n}","map":{"version":3,"names":["$242452271d1e4c0e$export$8c18d1b4f7232bbf","props","state","buttonRef","popoverRef","inputRef","listBoxRef","keyboardDelegate","layoutDelegate","shouldFocusWrap","isReadOnly","isDisabled","backupBtnRef","$BGXP4$react","useRef","stringFormatter","$BGXP4$reactariai18n","useLocalizedStringFormatter","$parcel$interopDefault","$8d1e5da058b86bb9$exports","_ref2","$BGXP4$reactariamenu","useMenuTrigger","type","menuTriggerProps","menuProps","$BGXP4$reactarialistbox","listData","set","id","collection","disabledKeys","selectionManager","delegate","useMemo","$BGXP4$reactariaselection","ListKeyboardDelegate","ref","_ref3","useSelectableCollection","disallowTypeAhead","disallowEmptySelection","isVirtualized","collectionProps","router","$BGXP4$reactariautils","useRouter","onKeyDown","e","nativeEvent","isComposing","key","isOpen","preventDefault","current","focusedKey","collectionItem","getItem","href","item","querySelector","CSS","escape","toString","HTMLAnchorElement","open","routerOptions","close","onAction","commit","selectedKey","inputValue","allowsCustomValue","continuePropagation","revert","setFocusedKey","onBlur","_popoverRef_current","blurFromButton","relatedTarget","blurIntoPopover","contains","setFocused","onFocus","isFocused","_state$displayValidat","displayValidation","isInvalid","validationErrors","validationDetails","_ref4","$BGXP4$reactariatextfield","useTextField","Object","assign","_defineProperty","onChange","setInputValue","chain","value","defaultValue","defaultInputValue","autoComplete","validate","undefined","$BGXP4$reactstatelyform","privateValidationStateProp","labelProps","inputProps","descriptionProps","errorMessageProps","onPress","pointerType","_inputRef_current","focus","toggle","onPressStart","triggerLabelProps","useLabels","format","listBoxProps","lastEventTime","onTouchEnd","timeStamp","rect","target","getBoundingClientRect","touch","changedTouches","centerX","Math","ceil","left","width","centerY","top","height","clientX","clientY","_inputRef_current1","focusedItem","_focusedItem_parentKey","sectionKey","parentKey","_state_selectionManager_focusedKey","itemKey","lastSection","lastItem","useEffect","isAppleDevice","isSelected","section","sectionTitle","rendered","_ref","announcement","isGroupChange","groupTitle","groupCount","_toConsumableArray","$BGXP4$reactstatelycollections","getChildNodes","length","optionText","textValue","$BGXP4$reactarialiveannouncer","announce","optionCount","getItemCount","lastSize","lastOpen","didOpenWithoutFocusedItem","lastSelectedKey","selectedItem","$BGXP4$reactariaoverlays","ariaHideOutside","filter","element","useUpdateEffect","getActiveElement","getOwnerDocument","$BGXP4$reactariafocus","dispatchVirtualFocus","useEvent","buttonProps","excludeFromTabOrder","preventFocusOnPress","mergeProps","role","getItemId","autoCorrect","spellCheck","autoFocus","focusStrategy","shouldUseVirtualFocus","shouldSelectOnPressUp","shouldFocusOnHover","linkBehavior"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\combobox\\dist\\packages\\@react-aria\\combobox\\src\\useComboBox.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {announce} from '@react-aria/live-announcer';\nimport {AriaButtonProps} from '@react-types/button';\nimport {AriaComboBoxProps} from '@react-types/combobox';\nimport {ariaHideOutside} from '@react-aria/overlays';\nimport {AriaListBoxOptions, getItemId, listData} from '@react-aria/listbox';\nimport {BaseEvent, DOMAttributes, KeyboardDelegate, LayoutDelegate, PressEvent, RefObject, RouterOptions, ValidationResult} from '@react-types/shared';\nimport {chain, getActiveElement, getOwnerDocument, isAppleDevice, mergeProps, useEvent, useLabels, useRouter, useUpdateEffect} from '@react-aria/utils';\nimport {ComboBoxState} from '@react-stately/combobox';\nimport {dispatchVirtualFocus} from '@react-aria/focus';\nimport {FocusEvent, InputHTMLAttributes, KeyboardEvent, TouchEvent, useEffect, useMemo, useRef} from 'react';\nimport {getChildNodes, getItemCount} from '@react-stately/collections';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {ListKeyboardDelegate, useSelectableCollection} from '@react-aria/selection';\nimport {privateValidationStateProp} from '@react-stately/form';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useMenuTrigger} from '@react-aria/menu';\nimport {useTextField} from '@react-aria/textfield';\n\nexport interface AriaComboBoxOptions<T> extends Omit<AriaComboBoxProps<T>, 'children'> {\n  /** The ref for the input element. */\n  inputRef: RefObject<HTMLInputElement | null>,\n  /** The ref for the list box popover. */\n  popoverRef: RefObject<Element | null>,\n  /** The ref for the list box. */\n  listBoxRef: RefObject<HTMLElement | null>,\n  /** The ref for the optional list box popup trigger button.  */\n  buttonRef?: RefObject<Element | null>,\n  /** An optional keyboard delegate implementation, to override the default. */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * A delegate object that provides layout information for items in the collection.\n   * By default this uses the DOM, but this can be overridden to implement things like\n   * virtualized scrolling.\n   */\n  layoutDelegate?: LayoutDelegate\n}\n\nexport interface ComboBoxAria<T> extends ValidationResult {\n  /** Props for the label element. */\n  labelProps: DOMAttributes,\n  /** Props for the combo box input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n  /** Props for the list box, to be passed to [useListBox](useListBox.html). */\n  listBoxProps: AriaListBoxOptions<T>,\n  /** Props for the optional trigger button, to be passed to [useButton](useButton.html). */\n  buttonProps: AriaButtonProps,\n  /** Props for the combo box description element, if any. */\n  descriptionProps: DOMAttributes,\n  /** Props for the combo box error message element, if any. */\n  errorMessageProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a combo box component.\n * A combo box combines a text input with a listbox, allowing users to filter a list of options to items matching a query.\n * @param props - Props for the combo box.\n * @param state - State for the select, as returned by `useComboBoxState`.\n */\nexport function useComboBox<T>(props: AriaComboBoxOptions<T>, state: ComboBoxState<T>): ComboBoxAria<T> {\n  let {\n    buttonRef,\n    popoverRef,\n    inputRef,\n    listBoxRef,\n    keyboardDelegate,\n    layoutDelegate,\n    // completionMode = 'suggest',\n    shouldFocusWrap,\n    isReadOnly,\n    isDisabled\n  } = props;\n  let backupBtnRef = useRef(null);\n  buttonRef = buttonRef ?? backupBtnRef;\n\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/combobox');\n  let {menuTriggerProps, menuProps} = useMenuTrigger<T>(\n    {\n      type: 'listbox',\n      isDisabled: isDisabled || isReadOnly\n    },\n    state,\n    buttonRef\n  );\n\n  // Set listbox id so it can be used when calling getItemId later\n  listData.set(state, {id: menuProps.id});\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let {collection} = state;\n  let {disabledKeys} = state.selectionManager;\n  let delegate = useMemo(() => (\n    keyboardDelegate || new ListKeyboardDelegate({\n      collection,\n      disabledKeys,\n      ref: listBoxRef,\n      layoutDelegate\n    })\n  ), [keyboardDelegate, layoutDelegate, collection, disabledKeys, listBoxRef]);\n\n  // Use useSelectableCollection to get the keyboard handlers to apply to the textfield\n  let {collectionProps} = useSelectableCollection({\n    selectionManager: state.selectionManager,\n    keyboardDelegate: delegate,\n    disallowTypeAhead: true,\n    disallowEmptySelection: true,\n    shouldFocusWrap,\n    ref: inputRef,\n    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component\n    isVirtualized: true\n  });\n\n  let router = useRouter();\n\n  // For textfield specific keydown operations\n  let onKeyDown = (e: BaseEvent<KeyboardEvent<any>>) => {\n    if (e.nativeEvent.isComposing) {\n      return;\n    }\n    switch (e.key) {\n      case 'Enter':\n      case 'Tab':\n        // Prevent form submission if menu is open since we may be selecting a option\n        if (state.isOpen && e.key === 'Enter') {\n          e.preventDefault();\n        }\n\n        // If the focused item is a link, trigger opening it. Items that are links are not selectable.\n        if (state.isOpen && listBoxRef.current && state.selectionManager.focusedKey != null) {\n          let collectionItem = state.collection.getItem(state.selectionManager.focusedKey);\n          if (collectionItem?.props.href) {\n            let item = listBoxRef.current.querySelector(`[data-key=\"${CSS.escape(state.selectionManager.focusedKey.toString())}\"]`);\n            if (e.key === 'Enter' && item instanceof HTMLAnchorElement) {\n              router.open(item, e, collectionItem.props.href, collectionItem.props.routerOptions as RouterOptions);\n            }\n            state.close();\n            break;\n          } else if (collectionItem?.props.onAction) {\n            collectionItem.props.onAction();\n            state.close();\n            break;\n          }\n        }\n        state.commit();\n        break;\n      case 'Escape':\n        if (\n          state.selectedKey !== null ||\n          state.inputValue === '' ||\n          props.allowsCustomValue\n        ) {\n          e.continuePropagation();\n        }\n        state.revert();\n        break;\n      case 'ArrowDown':\n        state.open('first', 'manual');\n        break;\n      case 'ArrowUp':\n        state.open('last', 'manual');\n        break;\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        state.selectionManager.setFocusedKey(null);\n        break;\n    }\n  };\n\n  let onBlur = (e: FocusEvent<HTMLInputElement>) => {\n    let blurFromButton = buttonRef?.current && buttonRef.current === e.relatedTarget;\n    let blurIntoPopover = popoverRef.current?.contains(e.relatedTarget);\n    // Ignore blur if focused moved to the button(if exists) or into the popover.\n    if (blurFromButton || blurIntoPopover) {\n      return;\n    }\n\n    if (props.onBlur) {\n      props.onBlur(e);\n    }\n\n    state.setFocused(false);\n  };\n\n  let onFocus = (e: FocusEvent<HTMLInputElement>) => {\n    if (state.isFocused) {\n      return;\n    }\n\n    if (props.onFocus) {\n      props.onFocus(e);\n    }\n\n    state.setFocused(true);\n  };\n\n  let {isInvalid, validationErrors, validationDetails} = state.displayValidation;\n  let {labelProps, inputProps, descriptionProps, errorMessageProps} = useTextField({\n    ...props,\n    onChange: state.setInputValue,\n    onKeyDown: !isReadOnly ? chain(state.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown) : props.onKeyDown,\n    onBlur,\n    value: state.inputValue,\n    defaultValue: state.defaultInputValue,\n    onFocus,\n    autoComplete: 'off',\n    validate: undefined,\n    [privateValidationStateProp]: state\n  }, inputRef);\n\n  // Press handlers for the ComboBox button\n  let onPress = (e: PressEvent) => {\n    if (e.pointerType === 'touch') {\n      // Focus the input field in case it isn't focused yet\n      inputRef.current?.focus();\n      state.toggle(null, 'manual');\n    }\n  };\n\n  let onPressStart = (e: PressEvent) => {\n    if (e.pointerType !== 'touch') {\n      inputRef.current?.focus();\n      state.toggle((e.pointerType === 'keyboard' || e.pointerType === 'virtual') ? 'first' : null, 'manual');\n    }\n  };\n\n  let triggerLabelProps = useLabels({\n    id: menuTriggerProps.id,\n    'aria-label': stringFormatter.format('buttonLabel'),\n    'aria-labelledby': props['aria-labelledby'] || labelProps.id\n  });\n\n  let listBoxProps = useLabels({\n    id: menuProps.id,\n    'aria-label': stringFormatter.format('listboxLabel'),\n    'aria-labelledby': props['aria-labelledby'] || labelProps.id\n  });\n\n  // If a touch happens on direct center of ComboBox input, might be virtual click from iPad so open ComboBox menu\n  let lastEventTime = useRef(0);\n  let onTouchEnd = (e: TouchEvent) => {\n    if (isDisabled || isReadOnly) {\n      return;\n    }\n\n    // Sometimes VoiceOver on iOS fires two touchend events in quick succession. Ignore the second one.\n    if (e.timeStamp - lastEventTime.current < 500) {\n      e.preventDefault();\n      inputRef.current?.focus();\n      return;\n    }\n\n    let rect = (e.target as Element).getBoundingClientRect();\n    let touch = e.changedTouches[0];\n\n    let centerX = Math.ceil(rect.left + .5 * rect.width);\n    let centerY = Math.ceil(rect.top + .5 * rect.height);\n\n    if (touch.clientX === centerX && touch.clientY === centerY) {\n      e.preventDefault();\n      inputRef.current?.focus();\n      state.toggle(null, 'manual');\n\n      lastEventTime.current = e.timeStamp;\n    }\n  };\n\n  // VoiceOver has issues with announcing aria-activedescendant properly on change\n  // (especially on iOS). We use a live region announcer to announce focus changes\n  // manually. In addition, section titles are announced when navigating into a new section.\n  let focusedItem = state.selectionManager.focusedKey != null && state.isOpen\n    ? state.collection.getItem(state.selectionManager.focusedKey)\n    : undefined;\n  let sectionKey = focusedItem?.parentKey ?? null;\n  let itemKey = state.selectionManager.focusedKey ?? null;\n  let lastSection = useRef(sectionKey);\n  let lastItem = useRef(itemKey);\n  useEffect(() => {\n    if (isAppleDevice() && focusedItem != null && itemKey != null && itemKey !== lastItem.current) {\n      let isSelected = state.selectionManager.isSelected(itemKey);\n      let section = sectionKey != null ? state.collection.getItem(sectionKey) : null;\n      let sectionTitle = section?.['aria-label'] || (typeof section?.rendered === 'string' ? section.rendered : '') || '';\n\n      let announcement = stringFormatter.format('focusAnnouncement', {\n        isGroupChange: (section && sectionKey !== lastSection.current) ?? false,\n        groupTitle: sectionTitle,\n        groupCount: section ? [...getChildNodes(section, state.collection)].length : 0,\n        optionText: focusedItem['aria-label'] || focusedItem.textValue || '',\n        isSelected\n      });\n\n      announce(announcement);\n    }\n\n    lastSection.current = sectionKey;\n    lastItem.current = itemKey;\n  });\n\n  // Announce the number of available suggestions when it changes\n  let optionCount = getItemCount(state.collection);\n  let lastSize = useRef(optionCount);\n  let lastOpen = useRef(state.isOpen);\n  useEffect(() => {\n    // Only announce the number of options available when the menu opens if there is no\n    // focused item, otherwise screen readers will typically read e.g. \"1 of 6\".\n    // The exception is VoiceOver since this isn't included in the message above.\n    let didOpenWithoutFocusedItem =\n      state.isOpen !== lastOpen.current &&\n      (state.selectionManager.focusedKey == null || isAppleDevice());\n\n    if (state.isOpen && (didOpenWithoutFocusedItem || optionCount !== lastSize.current)) {\n      let announcement = stringFormatter.format('countAnnouncement', {optionCount});\n      announce(announcement);\n    }\n\n    lastSize.current = optionCount;\n    lastOpen.current = state.isOpen;\n  });\n\n  // Announce when a selection occurs for VoiceOver. Other screen readers typically do this automatically.\n  let lastSelectedKey = useRef(state.selectedKey);\n  useEffect(() => {\n    if (isAppleDevice() && state.isFocused && state.selectedItem && state.selectedKey !== lastSelectedKey.current) {\n      let optionText = state.selectedItem['aria-label'] || state.selectedItem.textValue || '';\n      let announcement = stringFormatter.format('selectedAnnouncement', {optionText});\n      announce(announcement);\n    }\n\n    lastSelectedKey.current = state.selectedKey;\n  });\n\n  useEffect(() => {\n    if (state.isOpen) {\n      return ariaHideOutside([inputRef.current, popoverRef.current].filter(element => element != null));\n    }\n  }, [state.isOpen, inputRef, popoverRef]);\n\n  useUpdateEffect(() => {\n    // Re-show focus ring when there is no virtually focused item.\n    if (!focusedItem && inputRef.current && getActiveElement(getOwnerDocument(inputRef.current)) === inputRef.current) {\n      dispatchVirtualFocus(inputRef.current, null);\n    }\n  }, [focusedItem]);\n\n  useEvent(listBoxRef, 'react-aria-item-action', state.isOpen ? () => {\n    state.close();\n  } : undefined);\n\n  return {\n    labelProps,\n    buttonProps: {\n      ...menuTriggerProps,\n      ...triggerLabelProps,\n      excludeFromTabOrder: true,\n      preventFocusOnPress: true,\n      onPress,\n      onPressStart,\n      isDisabled: isDisabled || isReadOnly\n    },\n    inputProps: mergeProps(inputProps, {\n      role: 'combobox',\n      'aria-expanded': menuTriggerProps['aria-expanded'],\n      'aria-controls': state.isOpen ? menuProps.id : undefined,\n      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)\n      'aria-autocomplete': 'list',\n      'aria-activedescendant': focusedItem ? getItemId(state, focusedItem.key) : undefined,\n      onTouchEnd,\n      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.\n      autoCorrect: 'off',\n      // This disable's the macOS Safari spell check auto corrections.\n      spellCheck: 'false'\n    }),\n    listBoxProps: mergeProps(menuProps, listBoxProps, {\n      autoFocus: state.focusStrategy || true,\n      shouldUseVirtualFocus: true,\n      shouldSelectOnPressUp: true,\n      shouldFocusOnHover: true,\n      linkBehavior: 'selection' as const,\n      ['UNSTABLE_itemBehavior']: 'action'\n    }),\n    descriptionProps,\n    errorMessageProps,\n    isInvalid,\n    validationErrors,\n    validationDetails\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}