{"ast":null,"code":"var $ee0bdf4faa47f2a8$exports = require(\"./utils.main.js\");\nvar $a1189052f36475e8$exports = require(\"./useTypeSelect.main.js\");\nvar $bT8Bh$reactariautils = require(\"@react-aria/utils\");\nvar $bT8Bh$reactariafocus = require(\"@react-aria/focus\");\nvar $bT8Bh$reactdom = require(\"react-dom\");\nvar $bT8Bh$react = require(\"react\");\nvar $bT8Bh$reactariainteractions = require(\"@react-aria/interactions\");\nvar $bT8Bh$reactariai18n = require(\"@react-aria/i18n\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n$parcel$export(module.exports, \"useSelectableCollection\", function () {\n  return $b6837c2f80a3c32f$export$d6daf82dcd84e87c;\n});\nfunction $b6837c2f80a3c32f$export$d6daf82dcd84e87c(options) {\n  var manager = options.selectionManager,\n    delegate = options.keyboardDelegate,\n    ref = options.ref,\n    _options$autoFocus = options.autoFocus,\n    autoFocus = _options$autoFocus === void 0 ? false : _options$autoFocus,\n    _options$shouldFocusW = options.shouldFocusWrap,\n    shouldFocusWrap = _options$shouldFocusW === void 0 ? false : _options$shouldFocusW,\n    _options$disallowEmpt = options.disallowEmptySelection,\n    disallowEmptySelection = _options$disallowEmpt === void 0 ? false : _options$disallowEmpt,\n    _options$disallowSele = options.disallowSelectAll,\n    disallowSelectAll = _options$disallowSele === void 0 ? false : _options$disallowSele,\n    _options$escapeKeyBeh = options.escapeKeyBehavior,\n    escapeKeyBehavior = _options$escapeKeyBeh === void 0 ? 'clearSelection' : _options$escapeKeyBeh,\n    _options$selectOnFocu = options.selectOnFocus,\n    selectOnFocus = _options$selectOnFocu === void 0 ? manager.selectionBehavior === 'replace' : _options$selectOnFocu,\n    _options$disallowType = options.disallowTypeAhead,\n    disallowTypeAhead = _options$disallowType === void 0 ? false : _options$disallowType,\n    shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n    _options$allowsTabNav = options.allowsTabNavigation,\n    allowsTabNavigation = _options$allowsTabNav === void 0 ? false : _options$allowsTabNav,\n    isVirtualized = options.isVirtualized,\n    _options$scrollRef = options.scrollRef,\n    scrollRef = _options$scrollRef === void 0 ? ref : _options$scrollRef,\n    _options$linkBehavior = options.linkBehavior,\n    linkBehavior = _options$linkBehavior === void 0 ? 'action' : _options$linkBehavior;\n  var _ref = (0, $bT8Bh$reactariai18n.useLocale)(),\n    direction = _ref.direction;\n  var router = (0, $bT8Bh$reactariautils.useRouter)();\n  var onKeyDown = function onKeyDown(e) {\n    var _ref_current;\n    if (e.altKey && e.key === 'Tab') e.preventDefault();\n    if (!((_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.contains(e.target))) return;\n    var navigateToKey = function navigateToKey(key, childFocus) {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === 'selection' && selectOnFocus && !(0, $ee0bdf4faa47f2a8$exports.isNonContiguousSelectionModifier)(e)) {\n          (0, $bT8Bh$reactdom.flushSync)(function () {\n            manager.setFocusedKey(key, childFocus);\n          });\n          var item = (0, $ee0bdf4faa47f2a8$exports.getItemElement)(ref, key);\n          var itemProps = manager.getItemProps(key);\n          if (item) router.open(item, e, itemProps.href, itemProps.routerOptions);\n          return;\n        }\n        manager.setFocusedKey(key, childFocus);\n        if (manager.isLink(key) && linkBehavior === 'override') return;\n        if (e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(key);else if (selectOnFocus && !(0, $ee0bdf4faa47f2a8$exports.isNonContiguousSelectionModifier)(e)) manager.replaceSelection(key);\n      }\n    };\n    switch (e.key) {\n      case 'ArrowDown':\n        if (delegate.getKeyBelow) {\n          var _delegate_getKeyBelow, _delegate_getFirstKey, _delegate_getFirstKey1;\n          var nextKey = manager.focusedKey != null ? (_delegate_getKeyBelow = delegate.getKeyBelow) === null || _delegate_getKeyBelow === void 0 ? void 0 : _delegate_getKeyBelow.call(delegate, manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      case 'ArrowUp':\n        if (delegate.getKeyAbove) {\n          var _delegate_getKeyAbove, _delegate_getLastKey, _delegate_getLastKey1;\n          var _nextKey = manager.focusedKey != null ? (_delegate_getKeyAbove = delegate.getKeyAbove) === null || _delegate_getKeyAbove === void 0 ? void 0 : _delegate_getKeyAbove.call(delegate, manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);\n          if (_nextKey == null && shouldFocusWrap) _nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);\n          if (_nextKey != null) {\n            e.preventDefault();\n            navigateToKey(_nextKey);\n          }\n        }\n        break;\n      case 'ArrowLeft':\n        if (delegate.getKeyLeftOf) {\n          var _delegate_getKeyLeftOf, _delegate_getFirstKey2, _delegate_getLastKey2;\n          var _nextKey2 = manager.focusedKey != null ? (_delegate_getKeyLeftOf = delegate.getKeyLeftOf) === null || _delegate_getKeyLeftOf === void 0 ? void 0 : _delegate_getKeyLeftOf.call(delegate, manager.focusedKey) : null;\n          if (_nextKey2 == null && shouldFocusWrap) _nextKey2 = direction === 'rtl' ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);\n          if (_nextKey2 != null) {\n            e.preventDefault();\n            navigateToKey(_nextKey2, direction === 'rtl' ? 'first' : 'last');\n          }\n        }\n        break;\n      case 'ArrowRight':\n        if (delegate.getKeyRightOf) {\n          var _delegate_getKeyRightOf, _delegate_getLastKey3, _delegate_getFirstKey3;\n          var _nextKey3 = manager.focusedKey != null ? (_delegate_getKeyRightOf = delegate.getKeyRightOf) === null || _delegate_getKeyRightOf === void 0 ? void 0 : _delegate_getKeyRightOf.call(delegate, manager.focusedKey) : null;\n          if (_nextKey3 == null && shouldFocusWrap) _nextKey3 = direction === 'rtl' ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);\n          if (_nextKey3 != null) {\n            e.preventDefault();\n            navigateToKey(_nextKey3, direction === 'rtl' ? 'last' : 'first');\n          }\n        }\n        break;\n      case 'Home':\n        if (delegate.getFirstKey) {\n          if (manager.focusedKey === null && e.shiftKey) return;\n          e.preventDefault();\n          var firstKey = delegate.getFirstKey(manager.focusedKey, (0, $bT8Bh$reactariautils.isCtrlKeyPressed)(e));\n          manager.setFocusedKey(firstKey);\n          if (firstKey != null) {\n            if ((0, $bT8Bh$reactariautils.isCtrlKeyPressed)(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          if (manager.focusedKey === null && e.shiftKey) return;\n          e.preventDefault();\n          var lastKey = delegate.getLastKey(manager.focusedKey, (0, $bT8Bh$reactariautils.isCtrlKeyPressed)(e));\n          manager.setFocusedKey(lastKey);\n          if (lastKey != null) {\n            if ((0, $bT8Bh$reactariautils.isCtrlKeyPressed)(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow && manager.focusedKey != null) {\n          var _nextKey4 = delegate.getKeyPageBelow(manager.focusedKey);\n          if (_nextKey4 != null) {\n            e.preventDefault();\n            navigateToKey(_nextKey4);\n          }\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove && manager.focusedKey != null) {\n          var _nextKey5 = delegate.getKeyPageAbove(manager.focusedKey);\n          if (_nextKey5 != null) {\n            e.preventDefault();\n            navigateToKey(_nextKey5);\n          }\n        }\n        break;\n      case 'a':\n        if ((0, $bT8Bh$reactariautils.isCtrlKeyPressed)(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        if (escapeKeyBehavior === 'clearSelection' && !disallowEmptySelection && manager.selectedKeys.size !== 0) {\n          e.stopPropagation();\n          e.preventDefault();\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab':\n        if (!allowsTabNavigation) {\n          if (e.shiftKey) ref.current.focus();else {\n            var walker = (0, $bT8Bh$reactariafocus.getFocusableTreeWalker)(ref.current, {\n              tabbable: true\n            });\n            var next = undefined;\n            var last;\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n            if (next && !next.contains(document.activeElement)) (0, $bT8Bh$reactariautils.focusWithoutScrolling)(next);\n          }\n          break;\n        }\n    }\n  };\n  var scrollPos = (0, $bT8Bh$react.useRef)({\n    top: 0,\n    left: 0\n  });\n  (0, $bT8Bh$reactariautils.useEvent)(scrollRef, 'scroll', isVirtualized ? undefined : function () {\n    var _scrollRef_current, _scrollRef_current1;\n    var _scrollRef_current_scrollTop, _scrollRef_current_scrollLeft;\n    scrollPos.current = {\n      top: (_scrollRef_current_scrollTop = (_scrollRef_current = scrollRef.current) === null || _scrollRef_current === void 0 ? void 0 : _scrollRef_current.scrollTop) !== null && _scrollRef_current_scrollTop !== void 0 ? _scrollRef_current_scrollTop : 0,\n      left: (_scrollRef_current_scrollLeft = (_scrollRef_current1 = scrollRef.current) === null || _scrollRef_current1 === void 0 ? void 0 : _scrollRef_current1.scrollLeft) !== null && _scrollRef_current_scrollLeft !== void 0 ? _scrollRef_current_scrollLeft : 0\n    };\n  });\n  var onFocus = function onFocus(e) {\n    if (manager.isFocused) {\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    }\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n    if (manager.focusedKey == null) {\n      var _delegate_getLastKey, _delegate_getFirstKey;\n      var navigateToKey = function navigateToKey(key) {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus && !manager.isSelected(key)) manager.replaceSelection(key);\n        }\n      };\n      var relatedTarget = e.relatedTarget;\n      var _manager_lastSelectedKey, _manager_firstSelectedKey;\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate));else navigateToKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate));\n    } else if (!isVirtualized && scrollRef.current) {\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n    if (manager.focusedKey != null && scrollRef.current) {\n      var element = (0, $ee0bdf4faa47f2a8$exports.getItemElement)(ref, manager.focusedKey);\n      if (element instanceof HTMLElement) {\n        if (!element.contains(document.activeElement) && !shouldUseVirtualFocus) (0, $bT8Bh$reactariautils.focusWithoutScrolling)(element);\n        var modality = (0, $bT8Bh$reactariainteractions.getInteractionModality)();\n        if (modality === 'keyboard') (0, $bT8Bh$reactariautils.scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n  };\n  var onBlur = function onBlur(e) {\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n  var shouldVirtualFocusFirst = (0, $bT8Bh$react.useRef)(false);\n  (0, $bT8Bh$reactariautils.useEvent)(ref, (0, $bT8Bh$reactariautils.FOCUS_EVENT), !shouldUseVirtualFocus ? undefined : function (e) {\n    var detail = e.detail;\n    e.stopPropagation();\n    manager.setFocused(true);\n    if ((detail === null || detail === void 0 ? void 0 : detail.focusStrategy) === 'first') shouldVirtualFocusFirst.current = true;\n  });\n  var updateActiveDescendant = (0, $bT8Bh$reactariautils.useEffectEvent)(function () {\n    var _delegate_getFirstKey;\n    var _delegate_getFirstKey1;\n    var keyToFocus = (_delegate_getFirstKey1 = (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate)) !== null && _delegate_getFirstKey1 !== void 0 ? _delegate_getFirstKey1 : null;\n    if (keyToFocus == null) {\n      var previousActiveElement = (0, $bT8Bh$reactariautils.getActiveElement)();\n      (0, $bT8Bh$reactariafocus.moveVirtualFocus)(ref.current);\n      (0, $bT8Bh$reactariafocus.dispatchVirtualFocus)(previousActiveElement, null);\n      if (manager.collection.size > 0) shouldVirtualFocusFirst.current = false;\n    } else {\n      manager.setFocusedKey(keyToFocus);\n      shouldVirtualFocusFirst.current = false;\n    }\n  });\n  (0, $bT8Bh$reactariautils.useUpdateLayoutEffect)(function () {\n    if (shouldVirtualFocusFirst.current) updateActiveDescendant();\n  }, [manager.collection, updateActiveDescendant]);\n  var resetFocusFirstFlag = (0, $bT8Bh$reactariautils.useEffectEvent)(function () {\n    if (manager.collection.size > 0) shouldVirtualFocusFirst.current = false;\n  });\n  (0, $bT8Bh$reactariautils.useUpdateLayoutEffect)(function () {\n    resetFocusFirstFlag();\n  }, [manager.focusedKey, resetFocusFirstFlag]);\n  (0, $bT8Bh$reactariautils.useEvent)(ref, (0, $bT8Bh$reactariautils.CLEAR_FOCUS_EVENT), !shouldUseVirtualFocus ? undefined : function (e) {\n    var _e_detail;\n    e.stopPropagation();\n    manager.setFocused(false);\n    if ((_e_detail = e.detail) === null || _e_detail === void 0 ? void 0 : _e_detail.clearFocusKey) manager.setFocusedKey(null);\n  });\n  var autoFocusRef = (0, $bT8Bh$react.useRef)(autoFocus);\n  var didAutoFocusRef = (0, $bT8Bh$react.useRef)(false);\n  (0, $bT8Bh$react.useEffect)(function () {\n    if (autoFocusRef.current) {\n      var _delegate_getFirstKey, _delegate_getLastKey;\n      var focusedKey = null;\n      var _delegate_getFirstKey1;\n      if (autoFocus === 'first') focusedKey = (_delegate_getFirstKey1 = (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate)) !== null && _delegate_getFirstKey1 !== void 0 ? _delegate_getFirstKey1 : null;\n      var _delegate_getLastKey1;\n      if (autoFocus === 'last') focusedKey = (_delegate_getLastKey1 = (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate)) !== null && _delegate_getLastKey1 !== void 0 ? _delegate_getLastKey1 : null;\n      var selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        for (var key of selectedKeys) if (manager.canSelectItem(key)) {\n          focusedKey = key;\n          break;\n        }\n      }\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n      if (focusedKey == null && !shouldUseVirtualFocus && ref.current) (0, $bT8Bh$reactariainteractions.focusSafely)(ref.current);\n      if (manager.collection.size > 0) {\n        autoFocusRef.current = false;\n        didAutoFocusRef.current = true;\n      }\n    }\n  });\n  var lastFocusedKey = (0, $bT8Bh$react.useRef)(manager.focusedKey);\n  var raf = (0, $bT8Bh$react.useRef)(null);\n  (0, $bT8Bh$react.useEffect)(function () {\n    if (manager.isFocused && manager.focusedKey != null && (manager.focusedKey !== lastFocusedKey.current || didAutoFocusRef.current) && scrollRef.current && ref.current) {\n      var modality = (0, $bT8Bh$reactariainteractions.getInteractionModality)();\n      var element = (0, $ee0bdf4faa47f2a8$exports.getItemElement)(ref, manager.focusedKey);\n      if (!(element instanceof HTMLElement)) return;\n      if (modality === 'keyboard' || didAutoFocusRef.current) {\n        if (raf.current) cancelAnimationFrame(raf.current);\n        raf.current = requestAnimationFrame(function () {\n          if (scrollRef.current) {\n            (0, $bT8Bh$reactariautils.scrollIntoView)(scrollRef.current, element);\n            if (modality !== 'virtual') (0, $bT8Bh$reactariautils.scrollIntoViewport)(element, {\n              containingElement: ref.current\n            });\n          }\n        });\n      }\n    }\n    if (!shouldUseVirtualFocus && manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null && ref.current) (0, $bT8Bh$reactariainteractions.focusSafely)(ref.current);\n    lastFocusedKey.current = manager.focusedKey;\n    didAutoFocusRef.current = false;\n  });\n  (0, $bT8Bh$react.useEffect)(function () {\n    return function () {\n      if (raf.current) cancelAnimationFrame(raf.current);\n    };\n  }, []);\n  (0, $bT8Bh$reactariautils.useEvent)(ref, 'react-aria-focus-scope-restore', function (e) {\n    e.preventDefault();\n    manager.setFocused(true);\n  });\n  var handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown: function onMouseDown(e) {\n      if (scrollRef.current === e.target) e.preventDefault();\n    }\n  };\n  var _ref2 = (0, $a1189052f36475e8$exports.useTypeSelect)({\n      keyboardDelegate: delegate,\n      selectionManager: manager\n    }),\n    typeSelectProps = _ref2.typeSelectProps;\n  if (!disallowTypeAhead) handlers = (0, $bT8Bh$reactariautils.mergeProps)(typeSelectProps, handlers);\n  var tabIndex = undefined;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  var collectionId = (0, $ee0bdf4faa47f2a8$exports.useCollectionId)(manager.collection);\n  return {\n    collectionProps: (0, $bT8Bh$reactariautils.mergeProps)(handlers, {\n      tabIndex: tabIndex,\n      'data-collection': collectionId\n    })\n  };\n}","map":{"version":3,"names":["$b6837c2f80a3c32f$export$d6daf82dcd84e87c","options","manager","selectionManager","delegate","keyboardDelegate","ref","_options$autoFocus","autoFocus","_options$shouldFocusW","shouldFocusWrap","_options$disallowEmpt","disallowEmptySelection","_options$disallowSele","disallowSelectAll","_options$escapeKeyBeh","escapeKeyBehavior","_options$selectOnFocu","selectOnFocus","selectionBehavior","_options$disallowType","disallowTypeAhead","shouldUseVirtualFocus","_options$allowsTabNav","allowsTabNavigation","isVirtualized","_options$scrollRef","scrollRef","_options$linkBehavior","linkBehavior","_ref","$bT8Bh$reactariai18n","useLocale","direction","router","$bT8Bh$reactariautils","useRouter","onKeyDown","e","_ref_current","altKey","key","preventDefault","current","contains","target","navigateToKey","childFocus","isLink","$ee0bdf4faa47f2a8$exports","isNonContiguousSelectionModifier","$bT8Bh$reactdom","flushSync","setFocusedKey","item","getItemElement","itemProps","getItemProps","open","href","routerOptions","shiftKey","selectionMode","extendSelection","replaceSelection","getKeyBelow","_delegate_getKeyBelow","_delegate_getFirstKey","_delegate_getFirstKey1","nextKey","focusedKey","call","getFirstKey","getKeyAbove","_delegate_getKeyAbove","_delegate_getLastKey","_delegate_getLastKey1","getLastKey","getKeyLeftOf","_delegate_getKeyLeftOf","_delegate_getFirstKey2","_delegate_getLastKey2","getKeyRightOf","_delegate_getKeyRightOf","_delegate_getLastKey3","_delegate_getFirstKey3","firstKey","isCtrlKeyPressed","lastKey","getKeyPageBelow","getKeyPageAbove","selectAll","selectedKeys","size","stopPropagation","clearSelection","focus","walker","$bT8Bh$reactariafocus","getFocusableTreeWalker","tabbable","next","undefined","last","lastChild","document","activeElement","focusWithoutScrolling","scrollPos","$bT8Bh$react","useRef","top","left","useEvent","_scrollRef_current","_scrollRef_current1","_scrollRef_current_scrollTop","_scrollRef_current_scrollLeft","scrollTop","scrollLeft","onFocus","isFocused","currentTarget","setFocused","isSelected","relatedTarget","_manager_lastSelectedKey","_manager_firstSelectedKey","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","firstSelectedKey","element","HTMLElement","modality","$bT8Bh$reactariainteractions","getInteractionModality","scrollIntoViewport","containingElement","onBlur","shouldVirtualFocusFirst","FOCUS_EVENT","detail","focusStrategy","updateActiveDescendant","useEffectEvent","keyToFocus","previousActiveElement","getActiveElement","moveVirtualFocus","dispatchVirtualFocus","collection","useUpdateLayoutEffect","resetFocusFirstFlag","CLEAR_FOCUS_EVENT","_e_detail","clearFocusKey","autoFocusRef","didAutoFocusRef","useEffect","canSelectItem","focusSafely","lastFocusedKey","raf","cancelAnimationFrame","requestAnimationFrame","scrollIntoView","handlers","onMouseDown","_ref2","$a1189052f36475e8$exports","useTypeSelect","typeSelectProps","mergeProps","tabIndex","collectionId","useCollectionId","collectionProps"],"sources":["D:\\Programming\\Systems\\Hybrid-Systems\\RespondaPH\\mobile\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CLEAR_FOCUS_EVENT, FOCUS_EVENT, focusWithoutScrolling, getActiveElement, isCtrlKeyPressed, mergeProps, scrollIntoView, scrollIntoViewport, useEffectEvent, useEvent, useRouter, useUpdateLayoutEffect} from '@react-aria/utils';\nimport {dispatchVirtualFocus, getFocusableTreeWalker, moveVirtualFocus} from '@react-aria/focus';\nimport {DOMAttributes, FocusableElement, FocusStrategy, Key, KeyboardDelegate, RefObject} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {FocusEvent, KeyboardEvent, useEffect, useRef} from 'react';\nimport {focusSafely, getInteractionModality} from '@react-aria/interactions';\nimport {getItemElement, isNonContiguousSelectionModifier, useCollectionId} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\nexport interface AriaSelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement | null>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether pressing the Escape should clear selection in the collection or not.\n   * @default 'clearSelection'\n   */\n  escapeKeyBehavior?: 'clearSelection' | 'none',\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement | null>,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override'\n}\n\nexport interface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: DOMAttributes\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: AriaSelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    escapeKeyBehavior = 'clearSelection',\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref,\n    linkBehavior = 'action'\n  } = options;\n  let {direction} = useLocale();\n  let router = useRouter();\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current?.contains(e.target as Element)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === 'selection' && selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          flushSync(() => {\n            manager.setFocusedKey(key, childFocus);\n          });\n\n          let item = getItemElement(ref, key);\n          let itemProps = manager.getItemProps(key);\n          if (item) {\n            router.open(item, e, itemProps.href, itemProps.routerOptions);\n          }\n\n          return;\n        }\n\n        manager.setFocusedKey(key, childFocus);\n\n        if (manager.isLink(key) && linkBehavior === 'override') {\n          return;\n        }\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow?.(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove?.(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          let nextKey: Key | undefined | null = manager.focusedKey != null ? delegate.getKeyLeftOf?.(manager.focusedKey) : null;\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getFirstKey?.(manager.focusedKey) : delegate.getLastKey?.(manager.focusedKey);\n          }\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          let nextKey: Key | undefined | null = manager.focusedKey != null ? delegate.getKeyRightOf?.(manager.focusedKey) : null;\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = direction === 'rtl' ? delegate.getLastKey?.(manager.focusedKey) : delegate.getFirstKey?.(manager.focusedKey);\n          }\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n          }\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          if (manager.focusedKey === null && e.shiftKey) {\n            return;\n          }\n          e.preventDefault();\n          let firstKey: Key | null = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (firstKey != null) {\n            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(firstKey);\n            } else if (selectOnFocus) {\n              manager.replaceSelection(firstKey);\n            }\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          if (manager.focusedKey === null && e.shiftKey) {\n            return;\n          }\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (lastKey != null) {\n            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(lastKey);\n            } else if (selectOnFocus) {\n              manager.replaceSelection(lastKey);\n            }\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow && manager.focusedKey != null) {\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove && manager.focusedKey != null) {\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          if (nextKey != null) {\n            e.preventDefault();\n            navigateToKey(nextKey);\n          }\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        if (escapeKeyBehavior === 'clearSelection' && !disallowEmptySelection && manager.selectedKeys.size !== 0) {\n          e.stopPropagation();\n          e.preventDefault();\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: FocusableElement | undefined = undefined;\n            let last: FocusableElement;\n            do {\n              last = walker.lastChild() as FocusableElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  /// TODO: should this happen all the time??\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? undefined : () => {\n    scrollPos.current = {\n      top: scrollRef.current?.scrollTop ?? 0,\n      left: scrollRef.current?.scrollLeft ?? 0\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n    if (manager.focusedKey == null) {\n      let navigateToKey = (key: Key | undefined | null) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus && !manager.isSelected(key)) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToKey(manager.lastSelectedKey ?? delegate.getLastKey?.());\n      } else {\n        navigateToKey(manager.firstSelectedKey ?? delegate.getFirstKey?.());\n      }\n    } else if (!isVirtualized && scrollRef.current) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n\n    if (manager.focusedKey != null && scrollRef.current) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = getItemElement(ref, manager.focusedKey);\n      if (element instanceof HTMLElement) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement) && !shouldUseVirtualFocus) {\n          focusWithoutScrolling(element);\n        }\n\n        let modality = getInteractionModality();\n        if (modality === 'keyboard') {\n          scrollIntoViewport(element, {containingElement: ref.current});\n        }\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  // Ref to track whether the first item in the collection should be automatically focused. Specifically used for autocomplete when user types\n  // to focus the first key AFTER the collection updates.\n  // TODO: potentially expand the usage of this\n  let shouldVirtualFocusFirst = useRef(false);\n  // Add event listeners for custom virtual events. These handle updating the focused key in response to various keyboard events\n  // at the autocomplete level\n  // TODO: fix type later\n  useEvent(ref, FOCUS_EVENT, !shouldUseVirtualFocus ? undefined : (e: any) => {\n    let {detail} = e;\n    e.stopPropagation();\n    manager.setFocused(true);\n    // If the user is typing forwards, autofocus the first option in the list.\n    if (detail?.focusStrategy === 'first') {\n      shouldVirtualFocusFirst.current = true;\n    }\n  });\n\n  let updateActiveDescendant = useEffectEvent(() => {\n    let keyToFocus = delegate.getFirstKey?.() ?? null;\n\n    // If no focusable items exist in the list, make sure to clear any activedescendant that may still exist and move focus back to\n    // the original active element (e.g. the autocomplete input)\n    if (keyToFocus == null) {\n      let previousActiveElement = getActiveElement();\n      moveVirtualFocus(ref.current);\n      dispatchVirtualFocus(previousActiveElement!, null);\n\n      // If there wasn't a focusable key but the collection had items, then that means we aren't in an intermediate load state and all keys are disabled.\n      // Reset shouldVirtualFocusFirst so that we don't erronously autofocus an item when the collection is filtered again.\n      if (manager.collection.size > 0) {\n        shouldVirtualFocusFirst.current = false;\n      }\n    } else {\n      manager.setFocusedKey(keyToFocus);\n      // Only set shouldVirtualFocusFirst to false if we've successfully set the first key as the focused key\n      // If there wasn't a key to focus, we might be in a temporary loading state so we'll want to still focus the first key\n      // after the collection updates after load\n      shouldVirtualFocusFirst.current = false;\n    }\n  });\n\n  useUpdateLayoutEffect(() => {\n    if (shouldVirtualFocusFirst.current) {\n      updateActiveDescendant();\n    }\n\n  }, [manager.collection, updateActiveDescendant]);\n\n  let resetFocusFirstFlag = useEffectEvent(() => {\n    // If user causes the focused key to change in any other way, clear shouldVirtualFocusFirst so we don't\n    // accidentally move focus from under them. Skip this if the collection was empty because we might be in a load\n    // state and will still want to focus the first item after load\n    if (manager.collection.size > 0) {\n      shouldVirtualFocusFirst.current = false;\n    }\n  });\n\n  useUpdateLayoutEffect(() => {\n    resetFocusFirstFlag();\n  }, [manager.focusedKey, resetFocusFirstFlag]);\n\n  useEvent(ref, CLEAR_FOCUS_EVENT, !shouldUseVirtualFocus ? undefined : (e: any) => {\n    e.stopPropagation();\n    manager.setFocused(false);\n    if (e.detail?.clearFocusKey) {\n      manager.setFocusedKey(null);\n    }\n  });\n\n  const autoFocusRef = useRef(autoFocus);\n  const didAutoFocusRef = useRef(false);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey: Key | null = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey?.() ?? null;\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey?.() ?? null;\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        for (let key of selectedKeys) {\n          if (manager.canSelectItem(key)) {\n            focusedKey = key;\n            break;\n          }\n        }\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus && ref.current) {\n        focusSafely(ref.current);\n      }\n\n      // Wait until the collection has items to autofocus.\n      if (manager.collection.size > 0) {\n        autoFocusRef.current = false;\n        didAutoFocusRef.current = true;\n      }\n    }\n  });\n\n  // Scroll the focused element into view when the focusedKey changes.\n  let lastFocusedKey = useRef(manager.focusedKey);\n  let raf = useRef<number | null>(null);\n  useEffect(() => {\n    if (manager.isFocused && manager.focusedKey != null && (manager.focusedKey !== lastFocusedKey.current || didAutoFocusRef.current) && scrollRef.current && ref.current) {\n      let modality = getInteractionModality();\n      let element = getItemElement(ref, manager.focusedKey);\n      if (!(element instanceof HTMLElement)) {\n        // If item element wasn't found, return early (don't update autoFocusRef and lastFocusedKey).\n        // The collection may initially be empty (e.g. virtualizer), so wait until the element exists.\n        return;\n      }\n\n      if (modality === 'keyboard' || didAutoFocusRef.current) {\n\n        if (raf.current) {\n          cancelAnimationFrame(raf.current);\n        }\n\n        raf.current = requestAnimationFrame(() => {\n          if (scrollRef.current) {\n            scrollIntoView(scrollRef.current, element);\n            // Avoid scroll in iOS VO, since it may cause overlay to close (i.e. RAC submenu)\n            if (modality !== 'virtual') {\n              scrollIntoViewport(element, {containingElement: ref.current});\n            }\n          }\n        });\n      }\n    }\n\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (!shouldUseVirtualFocus && manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null && ref.current) {\n      focusSafely(ref.current);\n    }\n\n    lastFocusedKey.current = manager.focusedKey;\n    didAutoFocusRef.current = false;\n  });\n\n  useEffect(() => {\n    return () => {\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n    };\n  }, []);\n\n  // Intercept FocusScope restoration since virtualized collections can reuse DOM nodes.\n  useEvent(ref, 'react-aria-focus-scope-restore', e => {\n    e.preventDefault();\n    manager.setFocused(true);\n  });\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  let tabIndex: number | undefined = undefined;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  let collectionId = useCollectionId(manager.collection);\n  return {\n    collectionProps: mergeProps(handlers, {\n      tabIndex,\n      'data-collection': collectionId\n    })\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}